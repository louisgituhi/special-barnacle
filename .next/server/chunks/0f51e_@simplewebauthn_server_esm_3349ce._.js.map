{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoBase64URL.js"],"sourcesContent":["/**\n * A runtime-agnostic collection of methods for working with Base64URL encoding\n * @module\n */\nimport base64 from '@hexagon/base64';\n/**\n * Decode from a Base64URL-encoded string to an ArrayBuffer. Best used when converting a\n * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or\n * excludeCredentials.\n *\n * @param buffer Value to decode from base64\n * @param to (optional) The decoding to use, in case it's desirable to decode from base64 instead\n */\nexport function toBuffer(base64urlString, from = 'base64url') {\n    const _buffer = base64.toArrayBuffer(base64urlString, from === 'base64url');\n    return new Uint8Array(_buffer);\n}\n/**\n * Encode the given array buffer into a Base64URL-encoded string. Ideal for converting various\n * credential response ArrayBuffers to string for sending back to the server as JSON.\n *\n * @param buffer Value to encode to base64\n * @param to (optional) The encoding to use, in case it's desirable to encode to base64 instead\n */\nexport function fromBuffer(buffer, to = 'base64url') {\n    return base64.fromArrayBuffer(buffer, to === 'base64url');\n}\n/**\n * Convert a base64url string into base64\n */\nexport function toBase64(base64urlString) {\n    const fromBase64Url = base64.toArrayBuffer(base64urlString, true);\n    const toBase64 = base64.fromArrayBuffer(fromBase64Url);\n    return toBase64;\n}\n/**\n * Encode a UTF-8 string to base64url\n */\nexport function fromUTF8String(utf8String) {\n    return base64.fromString(utf8String, true);\n}\n/**\n * Decode a base64url string into its original UTF-8 string\n */\nexport function toUTF8String(base64urlString) {\n    return base64.toString(base64urlString, true);\n}\n/**\n * Confirm that the string is encoded into base64\n */\nexport function isBase64(input) {\n    return base64.validate(input, false);\n}\n/**\n * Confirm that the string is encoded into base64url, with support for optional padding\n */\nexport function isBase64URL(input) {\n    // Trim padding characters from the string if present\n    input = trimPadding(input);\n    return base64.validate(input, true);\n}\n/**\n * Remove optional padding from a base64url-encoded string\n */\nexport function trimPadding(input) {\n    return input.replace(/=/g, '');\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;AACD;;AASO,SAAS,SAAS,eAAe,EAAE,OAAO,WAAW;IACxD,MAAM,UAAU,uNAAA,CAAA,UAAM,CAAC,aAAa,CAAC,iBAAiB,SAAS;IAC/D,OAAO,IAAI,WAAW;AAC1B;AAQO,SAAS,WAAW,MAAM,EAAE,KAAK,WAAW;IAC/C,OAAO,uNAAA,CAAA,UAAM,CAAC,eAAe,CAAC,QAAQ,OAAO;AACjD;AAIO,SAAS,SAAS,eAAe;IACpC,MAAM,gBAAgB,uNAAA,CAAA,UAAM,CAAC,aAAa,CAAC,iBAAiB;IAC5D,MAAM,WAAW,uNAAA,CAAA,UAAM,CAAC,eAAe,CAAC;IACxC,OAAO;AACX;AAIO,SAAS,eAAe,UAAU;IACrC,OAAO,uNAAA,CAAA,UAAM,CAAC,UAAU,CAAC,YAAY;AACzC;AAIO,SAAS,aAAa,eAAe;IACxC,OAAO,uNAAA,CAAA,UAAM,CAAC,QAAQ,CAAC,iBAAiB;AAC5C;AAIO,SAAS,SAAS,KAAK;IAC1B,OAAO,uNAAA,CAAA,UAAM,CAAC,QAAQ,CAAC,OAAO;AAClC;AAIO,SAAS,YAAY,KAAK;IAC7B,qDAAqD;IACrD,QAAQ,YAAY;IACpB,OAAO,uNAAA,CAAA,UAAM,CAAC,QAAQ,CAAC,OAAO;AAClC;AAIO,SAAS,YAAY,KAAK;IAC7B,OAAO,MAAM,OAAO,CAAC,MAAM;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCBOR.js"],"sourcesContent":["/**\n * A runtime-agnostic collection of methods for working with CBOR encoding\n * @module\n */\nimport * as tinyCbor from '@levischuck/tiny-cbor';\n/**\n * Whatever CBOR encoder is used should keep CBOR data the same length when data is re-encoded\n *\n * MOST CRITICALLY, this means the following needs to be true of whatever CBOR library we use:\n * - CBOR Map type values MUST decode to JavaScript Maps\n * - CBOR tag 64 (uint8 Typed Array) MUST NOT be used when encoding Uint8Arrays back to CBOR\n *\n * So long as these requirements are maintained, then CBOR sequences can be encoded and decoded\n * freely while maintaining their lengths for the most accurate pointer movement across them.\n */\n/**\n * Decode and return the first item in a sequence of CBOR-encoded values\n *\n * @param input The CBOR data to decode\n * @param asObject (optional) Whether to convert any CBOR Maps into JavaScript Objects. Defaults to\n * `false`\n */\nexport function decodeFirst(input) {\n    // Make a copy so we don't mutate the original\n    const _input = new Uint8Array(input);\n    const decoded = tinyCbor.decodePartialCBOR(_input, 0);\n    const [first] = decoded;\n    return first;\n}\n/**\n * Encode data to CBOR\n */\nexport function encode(input) {\n    return tinyCbor.encodeCBOR(input);\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACD;AAAA;;AAkBO,SAAS,YAAY,KAAK;IAC7B,8CAA8C;IAC9C,MAAM,SAAS,IAAI,WAAW;IAC9B,MAAM,UAAU,wOAAS,iBAAiB,CAAC,QAAQ;IACnD,MAAM,CAAC,MAAM,GAAG;IAChB,OAAO;AACX;AAIO,SAAS,OAAO,KAAK;IACxB,OAAO,wOAAS,UAAU,CAAC;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/cose.js"],"sourcesContent":["/**\n * Fundamental values that are needed to discern the more specific COSE public key types below.\n *\n * The use of `Maps` here is due to CBOR encoding being used with public keys, and the CBOR \"Map\"\n * type is being decoded to JavaScript's `Map` type instead of, say, a basic Object as us JS\n * developers might prefer.\n *\n * These types are an unorthodox way of saying \"these Maps should involve these discrete lists of\n * keys\", but it works.\n * @module\n */\n/**\n * A type guard for determining if a COSE public key is an OKP key pair\n */\nexport function isCOSEPublicKeyOKP(cosePublicKey) {\n    const kty = cosePublicKey.get(COSEKEYS.kty);\n    return isCOSEKty(kty) && kty === COSEKTY.OKP;\n}\n/**\n * A type guard for determining if a COSE public key is an EC2 key pair\n */\nexport function isCOSEPublicKeyEC2(cosePublicKey) {\n    const kty = cosePublicKey.get(COSEKEYS.kty);\n    return isCOSEKty(kty) && kty === COSEKTY.EC2;\n}\n/**\n * A type guard for determining if a COSE public key is an RSA key pair\n */\nexport function isCOSEPublicKeyRSA(cosePublicKey) {\n    const kty = cosePublicKey.get(COSEKEYS.kty);\n    return isCOSEKty(kty) && kty === COSEKTY.RSA;\n}\n/**\n * COSE Keys\n *\n * https://www.iana.org/assignments/cose/cose.xhtml#key-common-parameters\n * https://www.iana.org/assignments/cose/cose.xhtml#key-type-parameters\n */\nexport var COSEKEYS;\n(function (COSEKEYS) {\n    COSEKEYS[COSEKEYS[\"kty\"] = 1] = \"kty\";\n    COSEKEYS[COSEKEYS[\"alg\"] = 3] = \"alg\";\n    COSEKEYS[COSEKEYS[\"crv\"] = -1] = \"crv\";\n    COSEKEYS[COSEKEYS[\"x\"] = -2] = \"x\";\n    COSEKEYS[COSEKEYS[\"y\"] = -3] = \"y\";\n    COSEKEYS[COSEKEYS[\"n\"] = -1] = \"n\";\n    COSEKEYS[COSEKEYS[\"e\"] = -2] = \"e\";\n})(COSEKEYS || (COSEKEYS = {}));\n/**\n * COSE Key Types\n *\n * https://www.iana.org/assignments/cose/cose.xhtml#key-type\n */\nexport var COSEKTY;\n(function (COSEKTY) {\n    COSEKTY[COSEKTY[\"OKP\"] = 1] = \"OKP\";\n    COSEKTY[COSEKTY[\"EC2\"] = 2] = \"EC2\";\n    COSEKTY[COSEKTY[\"RSA\"] = 3] = \"RSA\";\n})(COSEKTY || (COSEKTY = {}));\nexport function isCOSEKty(kty) {\n    return Object.values(COSEKTY).indexOf(kty) >= 0;\n}\n/**\n * COSE Curves\n *\n * https://www.iana.org/assignments/cose/cose.xhtml#elliptic-curves\n */\nexport var COSECRV;\n(function (COSECRV) {\n    COSECRV[COSECRV[\"P256\"] = 1] = \"P256\";\n    COSECRV[COSECRV[\"P384\"] = 2] = \"P384\";\n    COSECRV[COSECRV[\"P521\"] = 3] = \"P521\";\n    COSECRV[COSECRV[\"ED25519\"] = 6] = \"ED25519\";\n    COSECRV[COSECRV[\"SECP256K1\"] = 8] = \"SECP256K1\";\n})(COSECRV || (COSECRV = {}));\nexport function isCOSECrv(crv) {\n    return Object.values(COSECRV).indexOf(crv) >= 0;\n}\n/**\n * COSE Algorithms\n *\n * https://www.iana.org/assignments/cose/cose.xhtml#algorithms\n */\nexport var COSEALG;\n(function (COSEALG) {\n    COSEALG[COSEALG[\"ES256\"] = -7] = \"ES256\";\n    COSEALG[COSEALG[\"EdDSA\"] = -8] = \"EdDSA\";\n    COSEALG[COSEALG[\"ES384\"] = -35] = \"ES384\";\n    COSEALG[COSEALG[\"ES512\"] = -36] = \"ES512\";\n    COSEALG[COSEALG[\"PS256\"] = -37] = \"PS256\";\n    COSEALG[COSEALG[\"PS384\"] = -38] = \"PS384\";\n    COSEALG[COSEALG[\"PS512\"] = -39] = \"PS512\";\n    COSEALG[COSEALG[\"ES256K\"] = -47] = \"ES256K\";\n    COSEALG[COSEALG[\"RS256\"] = -257] = \"RS256\";\n    COSEALG[COSEALG[\"RS384\"] = -258] = \"RS384\";\n    COSEALG[COSEALG[\"RS512\"] = -259] = \"RS512\";\n    COSEALG[COSEALG[\"RS1\"] = -65535] = \"RS1\";\n})(COSEALG || (COSEALG = {}));\nexport function isCOSEAlg(alg) {\n    return Object.values(COSEALG).indexOf(alg) >= 0;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoAlg.js"],"sourcesContent":["import { COSEALG } from '../../cose.js';\n/**\n * Convert a COSE alg ID into a corresponding string value that WebCrypto APIs expect\n */\nexport function mapCoseAlgToWebCryptoAlg(alg) {\n    if ([COSEALG.RS1].indexOf(alg) >= 0) {\n        return 'SHA-1';\n    }\n    else if ([COSEALG.ES256, COSEALG.PS256, COSEALG.RS256].indexOf(alg) >= 0) {\n        return 'SHA-256';\n    }\n    else if ([COSEALG.ES384, COSEALG.PS384, COSEALG.RS384].indexOf(alg) >= 0) {\n        return 'SHA-384';\n    }\n    else if ([COSEALG.ES512, COSEALG.PS512, COSEALG.RS512, COSEALG.EdDSA].indexOf(alg) >=\n        0) {\n        return 'SHA-512';\n    }\n    throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto alg`);\n}\n"],"names":[],"mappings":";;;AAAA;;AAIO,SAAS,yBAAyB,GAAG;IACxC,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,GAAG;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACjC,OAAO;IACX,OACK,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACtE,OAAO;IACX,OACK,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACtE,OAAO;IACX,OACK,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;KAAC,CAAC,OAAO,CAAC,QAC1E,GAAG;QACH,OAAO;IACX;IACA,MAAM,IAAI,MAAM,CAAC,gCAAgC,EAAE,IAAI,mBAAmB,CAAC;AAC/E","ignoreList":[0]}},
    {"offset": {"line": 205, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/getWebCrypto.js"],"sourcesContent":["let webCrypto = undefined;\n/**\n * Try to get an instance of the Crypto API from the current runtime. Should support Node,\n * as well as others, like Deno, that implement Web APIs.\n */\nexport function getWebCrypto() {\n    /**\n     * Hello there! If you came here wondering why this method is asynchronous when use of\n     * `globalThis.crypto` is not, it's to minimize a bunch of refactor related to making this\n     * synchronous. For example, `generateRegistrationOptions()` and `generateAuthenticationOptions()`\n     * become synchronous if we make this synchronous (since nothing else in that method is async)\n     * which represents a breaking API change in this library's core API.\n     *\n     * TODO: If it's after February 2025 when you read this then consider whether it still makes sense\n     * to keep this method asynchronous.\n     */\n    const toResolve = new Promise((resolve, reject) => {\n        if (webCrypto) {\n            return resolve(webCrypto);\n        }\n        /**\n         * Naively attempt to access Crypto as a global object, which popular ESM-centric run-times\n         * support (and Node v20+)\n         */\n        const _globalThisCrypto = _getWebCryptoInternals.stubThisGlobalThisCrypto();\n        if (_globalThisCrypto) {\n            webCrypto = _globalThisCrypto;\n            return resolve(webCrypto);\n        }\n        // We tried to access it both in Node and globally, so bail out\n        return reject(new MissingWebCrypto());\n    });\n    return toResolve;\n}\nexport class MissingWebCrypto extends Error {\n    constructor() {\n        const message = 'An instance of the Crypto API could not be located';\n        super(message);\n        this.name = 'MissingWebCrypto';\n    }\n}\n// Make it possible to stub return values during testing\nexport const _getWebCryptoInternals = {\n    stubThisGlobalThisCrypto: () => globalThis.crypto,\n    // Make it possible to reset the `webCrypto` at the top of the file\n    setCachedCrypto: (newCrypto) => {\n        webCrypto = newCrypto;\n    },\n};\n"],"names":[],"mappings":";;;;;AAAA,IAAI,YAAY;AAKT,SAAS;IACZ;;;;;;;;;KASC,GACD,MAAM,YAAY,IAAI,QAAQ,CAAC,SAAS;QACpC,IAAI,WAAW;YACX,OAAO,QAAQ;QACnB;QACA;;;SAGC,GACD,MAAM,oBAAoB,uBAAuB,wBAAwB;QACzE,IAAI,mBAAmB;YACnB,YAAY;YACZ,OAAO,QAAQ;QACnB;QACA,+DAA+D;QAC/D,OAAO,OAAO,IAAI;IACtB;IACA,OAAO;AACX;AACO,MAAM,yBAAyB;IAClC,aAAc;QACV,MAAM,UAAU;QAChB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ;AAEO,MAAM,yBAAyB;IAClC,0BAA0B,IAAM,WAAW,MAAM;IACjD,mEAAmE;IACnE,iBAAiB,CAAC;QACd,YAAY;IAChB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/digest.js"],"sourcesContent":["import { mapCoseAlgToWebCryptoAlg } from './mapCoseAlgToWebCryptoAlg.js';\nimport { getWebCrypto } from './getWebCrypto.js';\n/**\n * Generate a digest of the provided data.\n *\n * @param data The data to generate a digest of\n * @param algorithm A COSE algorithm ID that maps to a desired SHA algorithm\n */\nexport async function digest(data, algorithm) {\n    const WebCrypto = await getWebCrypto();\n    const subtleAlgorithm = mapCoseAlgToWebCryptoAlg(algorithm);\n    const hashed = await WebCrypto.subtle.digest(subtleAlgorithm, data);\n    return new Uint8Array(hashed);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAOO,eAAe,OAAO,IAAI,EAAE,SAAS;IACxC,MAAM,YAAY,MAAM,CAAA,GAAA,0QAAA,CAAA,eAAY,AAAD;IACnC,MAAM,kBAAkB,CAAA,GAAA,sRAAA,CAAA,2BAAwB,AAAD,EAAE;IACjD,MAAM,SAAS,MAAM,UAAU,MAAM,CAAC,MAAM,CAAC,iBAAiB;IAC9D,OAAO,IAAI,WAAW;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 277, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/getRandomValues.js"],"sourcesContent":["import { getWebCrypto } from './getWebCrypto.js';\n/**\n * Fill up the provided bytes array with random bytes equal to its length.\n *\n * @returns the same bytes array passed into the method\n */\nexport async function getRandomValues(array) {\n    const WebCrypto = await getWebCrypto();\n    WebCrypto.getRandomValues(array);\n    return array;\n}\n"],"names":[],"mappings":";;;AAAA;;AAMO,eAAe,gBAAgB,KAAK;IACvC,MAAM,YAAY,MAAM,CAAA,GAAA,0QAAA,CAAA,eAAY,AAAD;IACnC,UAAU,eAAe,CAAC;IAC1B,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 299, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/importKey.js"],"sourcesContent":["import { getWebCrypto } from './getWebCrypto.js';\nexport async function importKey(opts) {\n    const WebCrypto = await getWebCrypto();\n    const { keyData, algorithm } = opts;\n    return WebCrypto.subtle.importKey('jwk', keyData, algorithm, false, [\n        'verify',\n    ]);\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,eAAe,UAAU,IAAI;IAChC,MAAM,YAAY,MAAM,CAAA,GAAA,0QAAA,CAAA,eAAY,AAAD;IACnC,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG;IAC/B,OAAO,UAAU,MAAM,CAAC,SAAS,CAAC,OAAO,SAAS,WAAW,OAAO;QAChE;KACH;AACL","ignoreList":[0]}},
    {"offset": {"line": 311, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 327, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyEC2.js"],"sourcesContent":["import { COSECRV, COSEKEYS } from '../../cose.js';\nimport { mapCoseAlgToWebCryptoAlg } from './mapCoseAlgToWebCryptoAlg.js';\nimport { importKey } from './importKey.js';\nimport { isoBase64URL } from '../index.js';\nimport { getWebCrypto } from './getWebCrypto.js';\n/**\n * Verify a signature using an EC2 public key\n */\nexport async function verifyEC2(opts) {\n    const { cosePublicKey, signature, data, shaHashOverride } = opts;\n    const WebCrypto = await getWebCrypto();\n    // Import the public key\n    const alg = cosePublicKey.get(COSEKEYS.alg);\n    const crv = cosePublicKey.get(COSEKEYS.crv);\n    const x = cosePublicKey.get(COSEKEYS.x);\n    const y = cosePublicKey.get(COSEKEYS.y);\n    if (!alg) {\n        throw new Error('Public key was missing alg (EC2)');\n    }\n    if (!crv) {\n        throw new Error('Public key was missing crv (EC2)');\n    }\n    if (!x) {\n        throw new Error('Public key was missing x (EC2)');\n    }\n    if (!y) {\n        throw new Error('Public key was missing y (EC2)');\n    }\n    let _crv;\n    if (crv === COSECRV.P256) {\n        _crv = 'P-256';\n    }\n    else if (crv === COSECRV.P384) {\n        _crv = 'P-384';\n    }\n    else if (crv === COSECRV.P521) {\n        _crv = 'P-521';\n    }\n    else {\n        throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);\n    }\n    const keyData = {\n        kty: 'EC',\n        crv: _crv,\n        x: isoBase64URL.fromBuffer(x),\n        y: isoBase64URL.fromBuffer(y),\n        ext: false,\n    };\n    const keyAlgorithm = {\n        /**\n         * Note to future self: you can't use `mapCoseAlgToWebCryptoKeyAlgName()` here because some\n         * leaf certs from actual devices specified an RSA SHA value for `alg` (e.g. `-257`) which\n         * would then map here to `'RSASSA-PKCS1-v1_5'`. We always want `'ECDSA'` here so we'll\n         * hard-code this.\n         */\n        name: 'ECDSA',\n        namedCurve: _crv,\n    };\n    const key = await importKey({\n        keyData,\n        algorithm: keyAlgorithm,\n    });\n    // Determine which SHA algorithm to use for signature verification\n    let subtleAlg = mapCoseAlgToWebCryptoAlg(alg);\n    if (shaHashOverride) {\n        subtleAlg = mapCoseAlgToWebCryptoAlg(shaHashOverride);\n    }\n    const verifyAlgorithm = {\n        name: 'ECDSA',\n        hash: { name: subtleAlg },\n    };\n    return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AADA;;;;;;AAKO,eAAe,UAAU,IAAI;IAChC,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG;IAC5D,MAAM,YAAY,MAAM,CAAA,GAAA,0QAAA,CAAA,eAAY,AAAD;IACnC,wBAAwB;IACxB,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IAC1C,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IAC1C,MAAM,IAAI,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IACtC,MAAM,IAAI,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IACtC,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,GAAG;QACJ,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,GAAG;QACJ,MAAM,IAAI,MAAM;IACpB;IACA,IAAI;IACJ,IAAI,QAAQ,8OAAA,CAAA,UAAO,CAAC,IAAI,EAAE;QACtB,OAAO;IACX,OACK,IAAI,QAAQ,8OAAA,CAAA,UAAO,CAAC,IAAI,EAAE;QAC3B,OAAO;IACX,OACK,IAAI,QAAQ,8OAAA,CAAA,UAAO,CAAC,IAAI,EAAE;QAC3B,OAAO;IACX,OACK;QACD,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,IAAI,MAAM,CAAC;IAC/D;IACA,MAAM,UAAU;QACZ,KAAK;QACL,KAAK;QACL,GAAG,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC;QAC3B,GAAG,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC;QAC3B,KAAK;IACT;IACA,MAAM,eAAe;QACjB;;;;;SAKC,GACD,MAAM;QACN,YAAY;IAChB;IACA,MAAM,MAAM,MAAM,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;QACxB;QACA,WAAW;IACf;IACA,kEAAkE;IAClE,IAAI,YAAY,CAAA,GAAA,sRAAA,CAAA,2BAAwB,AAAD,EAAE;IACzC,IAAI,iBAAiB;QACjB,YAAY,CAAA,GAAA,sRAAA,CAAA,2BAAwB,AAAD,EAAE;IACzC;IACA,MAAM,kBAAkB;QACpB,MAAM;QACN,MAAM;YAAE,MAAM;QAAU;IAC5B;IACA,OAAO,UAAU,MAAM,CAAC,MAAM,CAAC,iBAAiB,KAAK,WAAW;AACpE","ignoreList":[0]}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/mapCoseAlgToWebCryptoKeyAlgName.js"],"sourcesContent":["import { COSEALG } from '../../cose.js';\n/**\n * Convert a COSE alg ID into a corresponding key algorithm string value that WebCrypto APIs expect\n */\nexport function mapCoseAlgToWebCryptoKeyAlgName(alg) {\n    if ([COSEALG.EdDSA].indexOf(alg) >= 0) {\n        return 'Ed25519';\n    }\n    else if ([COSEALG.ES256, COSEALG.ES384, COSEALG.ES512, COSEALG.ES256K].indexOf(alg) >= 0) {\n        return 'ECDSA';\n    }\n    else if ([COSEALG.RS256, COSEALG.RS384, COSEALG.RS512, COSEALG.RS1].indexOf(alg) >= 0) {\n        return 'RSASSA-PKCS1-v1_5';\n    }\n    else if ([COSEALG.PS256, COSEALG.PS384, COSEALG.PS512].indexOf(alg) >= 0) {\n        return 'RSA-PSS';\n    }\n    throw new Error(`Could not map COSE alg value of ${alg} to a WebCrypto key alg name`);\n}\n"],"names":[],"mappings":";;;AAAA;;AAIO,SAAS,gCAAgC,GAAG;IAC/C,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACnC,OAAO;IACX,OACK,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,MAAM;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACtF,OAAO;IACX,OACK,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,GAAG;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACnF,OAAO;IACX,OACK,IAAI;QAAC,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;QAAE,8OAAA,CAAA,UAAO,CAAC,KAAK;KAAC,CAAC,OAAO,CAAC,QAAQ,GAAG;QACtE,OAAO;IACX;IACA,MAAM,IAAI,MAAM,CAAC,gCAAgC,EAAE,IAAI,4BAA4B,CAAC;AACxF","ignoreList":[0]}},
    {"offset": {"line": 443, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyRSA.js"],"sourcesContent":["import { COSEKEYS, isCOSEAlg } from '../../cose.js';\nimport { mapCoseAlgToWebCryptoAlg } from './mapCoseAlgToWebCryptoAlg.js';\nimport { importKey } from './importKey.js';\nimport { isoBase64URL } from '../index.js';\nimport { mapCoseAlgToWebCryptoKeyAlgName } from './mapCoseAlgToWebCryptoKeyAlgName.js';\nimport { getWebCrypto } from './getWebCrypto.js';\n/**\n * Verify a signature using an RSA public key\n */\nexport async function verifyRSA(opts) {\n    const { cosePublicKey, signature, data, shaHashOverride } = opts;\n    const WebCrypto = await getWebCrypto();\n    const alg = cosePublicKey.get(COSEKEYS.alg);\n    const n = cosePublicKey.get(COSEKEYS.n);\n    const e = cosePublicKey.get(COSEKEYS.e);\n    if (!alg) {\n        throw new Error('Public key was missing alg (RSA)');\n    }\n    if (!isCOSEAlg(alg)) {\n        throw new Error(`Public key had invalid alg ${alg} (RSA)`);\n    }\n    if (!n) {\n        throw new Error('Public key was missing n (RSA)');\n    }\n    if (!e) {\n        throw new Error('Public key was missing e (RSA)');\n    }\n    const keyData = {\n        kty: 'RSA',\n        alg: '',\n        n: isoBase64URL.fromBuffer(n),\n        e: isoBase64URL.fromBuffer(e),\n        ext: false,\n    };\n    const keyAlgorithm = {\n        name: mapCoseAlgToWebCryptoKeyAlgName(alg),\n        hash: { name: mapCoseAlgToWebCryptoAlg(alg) },\n    };\n    const verifyAlgorithm = {\n        name: mapCoseAlgToWebCryptoKeyAlgName(alg),\n    };\n    if (shaHashOverride) {\n        keyAlgorithm.hash.name = mapCoseAlgToWebCryptoAlg(shaHashOverride);\n    }\n    if (keyAlgorithm.name === 'RSASSA-PKCS1-v1_5') {\n        if (keyAlgorithm.hash.name === 'SHA-256') {\n            keyData.alg = 'RS256';\n        }\n        else if (keyAlgorithm.hash.name === 'SHA-384') {\n            keyData.alg = 'RS384';\n        }\n        else if (keyAlgorithm.hash.name === 'SHA-512') {\n            keyData.alg = 'RS512';\n        }\n        else if (keyAlgorithm.hash.name === 'SHA-1') {\n            keyData.alg = 'RS1';\n        }\n    }\n    else if (keyAlgorithm.name === 'RSA-PSS') {\n        /**\n         * salt length. The default value is 20 but the convention is to use hLen, the length of the\n         * output of the hash function in bytes. A salt length of zero is permitted and will result in\n         * a deterministic signature value. The actual salt length used can be determined from the\n         * signature value.\n         *\n         * From https://www.cryptosys.net/pki/manpki/pki_rsaschemes.html\n         */\n        let saltLength = 0;\n        if (keyAlgorithm.hash.name === 'SHA-256') {\n            keyData.alg = 'PS256';\n            saltLength = 32; // 256 bits => 32 bytes\n        }\n        else if (keyAlgorithm.hash.name === 'SHA-384') {\n            keyData.alg = 'PS384';\n            saltLength = 48; // 384 bits => 48 bytes\n        }\n        else if (keyAlgorithm.hash.name === 'SHA-512') {\n            keyData.alg = 'PS512';\n            saltLength = 64; // 512 bits => 64 bytes\n        }\n        verifyAlgorithm.saltLength = saltLength;\n    }\n    else {\n        throw new Error(`Unexpected RSA key algorithm ${alg} (${keyAlgorithm.name})`);\n    }\n    const key = await importKey({\n        keyData,\n        algorithm: keyAlgorithm,\n    });\n    return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;;;;;;;AAMO,eAAe,UAAU,IAAI;IAChC,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG;IAC5D,MAAM,YAAY,MAAM,CAAA,GAAA,0QAAA,CAAA,eAAY,AAAD;IACnC,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IAC1C,MAAM,IAAI,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IACtC,MAAM,IAAI,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IACtC,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,CAAA,GAAA,8OAAA,CAAA,YAAS,AAAD,EAAE,MAAM;QACjB,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,IAAI,MAAM,CAAC;IAC7D;IACA,IAAI,CAAC,GAAG;QACJ,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,GAAG;QACJ,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU;QACZ,KAAK;QACL,KAAK;QACL,GAAG,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC;QAC3B,GAAG,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC;QAC3B,KAAK;IACT;IACA,MAAM,eAAe;QACjB,MAAM,CAAA,GAAA,6RAAA,CAAA,kCAA+B,AAAD,EAAE;QACtC,MAAM;YAAE,MAAM,CAAA,GAAA,sRAAA,CAAA,2BAAwB,AAAD,EAAE;QAAK;IAChD;IACA,MAAM,kBAAkB;QACpB,MAAM,CAAA,GAAA,6RAAA,CAAA,kCAA+B,AAAD,EAAE;IAC1C;IACA,IAAI,iBAAiB;QACjB,aAAa,IAAI,CAAC,IAAI,GAAG,CAAA,GAAA,sRAAA,CAAA,2BAAwB,AAAD,EAAE;IACtD;IACA,IAAI,aAAa,IAAI,KAAK,qBAAqB;QAC3C,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW;YACtC,QAAQ,GAAG,GAAG;QAClB,OACK,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW;YAC3C,QAAQ,GAAG,GAAG;QAClB,OACK,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW;YAC3C,QAAQ,GAAG,GAAG;QAClB,OACK,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,SAAS;YACzC,QAAQ,GAAG,GAAG;QAClB;IACJ,OACK,IAAI,aAAa,IAAI,KAAK,WAAW;QACtC;;;;;;;SAOC,GACD,IAAI,aAAa;QACjB,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW;YACtC,QAAQ,GAAG,GAAG;YACd,aAAa,IAAI,uBAAuB;QAC5C,OACK,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW;YAC3C,QAAQ,GAAG,GAAG;YACd,aAAa,IAAI,uBAAuB;QAC5C,OACK,IAAI,aAAa,IAAI,CAAC,IAAI,KAAK,WAAW;YAC3C,QAAQ,GAAG,GAAG;YACd,aAAa,IAAI,uBAAuB;QAC5C;QACA,gBAAgB,UAAU,GAAG;IACjC,OACK;QACD,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,IAAI,EAAE,EAAE,aAAa,IAAI,CAAC,CAAC,CAAC;IAChF;IACA,MAAM,MAAM,MAAM,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;QACxB;QACA,WAAW;IACf;IACA,OAAO,UAAU,MAAM,CAAC,MAAM,CAAC,iBAAiB,KAAK,WAAW;AACpE","ignoreList":[0]}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 547, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoUint8Array.js"],"sourcesContent":["/**\n * A runtime-agnostic collection of methods for working with Uint8Arrays\n * @module\n */\n/**\n * Make sure two Uint8Arrays are deeply equivalent\n */\nexport function areEqual(array1, array2) {\n    if (array1.length != array2.length) {\n        return false;\n    }\n    return array1.every((val, i) => val === array2[i]);\n}\n/**\n * Convert a Uint8Array to Hexadecimal.\n *\n * A replacement for `Buffer.toString('hex')`\n */\nexport function toHex(array) {\n    const hexParts = Array.from(array, (i) => i.toString(16).padStart(2, '0'));\n    // adce000235bcc60a648b0b25f1f05503\n    return hexParts.join('');\n}\n/**\n * Convert a hexadecimal string to isoUint8Array.\n *\n * A replacement for `Buffer.from('...', 'hex')`\n */\nexport function fromHex(hex) {\n    if (!hex) {\n        return Uint8Array.from([]);\n    }\n    const isValid = hex.length !== 0 && hex.length % 2 === 0 &&\n        !/[^a-fA-F0-9]/u.test(hex);\n    if (!isValid) {\n        throw new Error('Invalid hex string');\n    }\n    const byteStrings = hex.match(/.{1,2}/g) ?? [];\n    return Uint8Array.from(byteStrings.map((byte) => parseInt(byte, 16)));\n}\n/**\n * Combine multiple Uint8Arrays into a single Uint8Array\n */\nexport function concat(arrays) {\n    let pointer = 0;\n    const totalLength = arrays.reduce((prev, curr) => prev + curr.length, 0);\n    const toReturn = new Uint8Array(totalLength);\n    arrays.forEach((arr) => {\n        toReturn.set(arr, pointer);\n        pointer += arr.length;\n    });\n    return toReturn;\n}\n/**\n * Convert bytes into a UTF-8 string\n */\nexport function toUTF8String(array) {\n    const decoder = new globalThis.TextDecoder('utf-8');\n    return decoder.decode(array);\n}\n/**\n * Convert a UTF-8 string back into bytes\n */\nexport function fromUTF8String(utf8String) {\n    const encoder = new globalThis.TextEncoder();\n    return encoder.encode(utf8String);\n}\n/**\n * Convert an ASCII string to Uint8Array\n */\nexport function fromASCIIString(value) {\n    return Uint8Array.from(value.split('').map((x) => x.charCodeAt(0)));\n}\n/**\n * Prepare a DataView we can slice our way around in as we parse the bytes in a Uint8Array\n */\nexport function toDataView(array) {\n    return new DataView(array.buffer, array.byteOffset, array.length);\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GACD;;CAEC;;;;;;;;;;AACM,SAAS,SAAS,MAAM,EAAE,MAAM;IACnC,IAAI,OAAO,MAAM,IAAI,OAAO,MAAM,EAAE;QAChC,OAAO;IACX;IACA,OAAO,OAAO,KAAK,CAAC,CAAC,KAAK,IAAM,QAAQ,MAAM,CAAC,EAAE;AACrD;AAMO,SAAS,MAAM,KAAK;IACvB,MAAM,WAAW,MAAM,IAAI,CAAC,OAAO,CAAC,IAAM,EAAE,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;IACrE,mCAAmC;IACnC,OAAO,SAAS,IAAI,CAAC;AACzB;AAMO,SAAS,QAAQ,GAAG;IACvB,IAAI,CAAC,KAAK;QACN,OAAO,WAAW,IAAI,CAAC,EAAE;IAC7B;IACA,MAAM,UAAU,IAAI,MAAM,KAAK,KAAK,IAAI,MAAM,GAAG,MAAM,KACnD,CAAC,gBAAgB,IAAI,CAAC;IAC1B,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,cAAc,IAAI,KAAK,CAAC,cAAc,EAAE;IAC9C,OAAO,WAAW,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC,OAAS,SAAS,MAAM;AACpE;AAIO,SAAS,OAAO,MAAM;IACzB,IAAI,UAAU;IACd,MAAM,cAAc,OAAO,MAAM,CAAC,CAAC,MAAM,OAAS,OAAO,KAAK,MAAM,EAAE;IACtE,MAAM,WAAW,IAAI,WAAW;IAChC,OAAO,OAAO,CAAC,CAAC;QACZ,SAAS,GAAG,CAAC,KAAK;QAClB,WAAW,IAAI,MAAM;IACzB;IACA,OAAO;AACX;AAIO,SAAS,aAAa,KAAK;IAC9B,MAAM,UAAU,IAAI,WAAW,WAAW,CAAC;IAC3C,OAAO,QAAQ,MAAM,CAAC;AAC1B;AAIO,SAAS,eAAe,UAAU;IACrC,MAAM,UAAU,IAAI,WAAW,WAAW;IAC1C,OAAO,QAAQ,MAAM,CAAC;AAC1B;AAIO,SAAS,gBAAgB,KAAK;IACjC,OAAO,WAAW,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,IAAM,EAAE,UAAU,CAAC;AACnE;AAIO,SAAS,WAAW,KAAK;IAC5B,OAAO,IAAI,SAAS,MAAM,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,MAAM;AACpE","ignoreList":[0]}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 624, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/convertAAGUIDToString.js"],"sourcesContent":["import { isoUint8Array } from './iso/index.js';\n/**\n * Convert the aaguid buffer in authData into a UUID string\n */\nexport function convertAAGUIDToString(aaguid) {\n    // Raw Hex: adce000235bcc60a648b0b25f1f05503\n    const hex = isoUint8Array.toHex(aaguid);\n    const segments = [\n        hex.slice(0, 8), // 8\n        hex.slice(8, 12), // 4\n        hex.slice(12, 16), // 4\n        hex.slice(16, 20), // 4\n        hex.slice(20, 32), // 8\n    ];\n    // Formatted: adce0002-35bc-c60a-648b-0b25f1f05503\n    return segments.join('-');\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAIO,SAAS,sBAAsB,MAAM;IACxC,4CAA4C;IAC5C,MAAM,MAAM,uSAAA,CAAA,gBAAa,CAAC,KAAK,CAAC;IAChC,MAAM,WAAW;QACb,IAAI,KAAK,CAAC,GAAG;QACb,IAAI,KAAK,CAAC,GAAG;QACb,IAAI,KAAK,CAAC,IAAI;QACd,IAAI,KAAK,CAAC,IAAI;QACd,IAAI,KAAK,CAAC,IAAI;KACjB;IACD,kDAAkD;IAClD,OAAO,SAAS,IAAI,CAAC;AACzB","ignoreList":[0]}},
    {"offset": {"line": 643, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 649, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/convertCertBufferToPEM.js"],"sourcesContent":["import { isoBase64URL } from './iso/index.js';\n/**\n * Convert buffer to an OpenSSL-compatible PEM text format.\n */\nexport function convertCertBufferToPEM(certBuffer) {\n    let b64cert;\n    /**\n     * Get certBuffer to a base64 representation\n     */\n    if (typeof certBuffer === 'string') {\n        if (isoBase64URL.isBase64URL(certBuffer)) {\n            b64cert = isoBase64URL.toBase64(certBuffer);\n        }\n        else if (isoBase64URL.isBase64(certBuffer)) {\n            b64cert = certBuffer;\n        }\n        else {\n            throw new Error('Certificate is not a valid base64 or base64url string');\n        }\n    }\n    else {\n        b64cert = isoBase64URL.fromBuffer(certBuffer, 'base64');\n    }\n    let PEMKey = '';\n    for (let i = 0; i < Math.ceil(b64cert.length / 64); i += 1) {\n        const start = 64 * i;\n        PEMKey += `${b64cert.substr(start, 64)}\\n`;\n    }\n    PEMKey = `-----BEGIN CERTIFICATE-----\\n${PEMKey}-----END CERTIFICATE-----\\n`;\n    return PEMKey;\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAIO,SAAS,uBAAuB,UAAU;IAC7C,IAAI;IACJ;;KAEC,GACD,IAAI,OAAO,eAAe,UAAU;QAChC,IAAI,qSAAA,CAAA,eAAY,CAAC,WAAW,CAAC,aAAa;YACtC,UAAU,qSAAA,CAAA,eAAY,CAAC,QAAQ,CAAC;QACpC,OACK,IAAI,qSAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,aAAa;YACxC,UAAU;QACd,OACK;YACD,MAAM,IAAI,MAAM;QACpB;IACJ,OACK;QACD,UAAU,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC,YAAY;IAClD;IACA,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAI,CAAC,QAAQ,MAAM,GAAG,KAAK,KAAK,EAAG;QACxD,MAAM,QAAQ,KAAK;QACnB,UAAU,GAAG,QAAQ,MAAM,CAAC,OAAO,IAAI,EAAE,CAAC;IAC9C;IACA,SAAS,CAAC,6BAA6B,EAAE,OAAO,2BAA2B,CAAC;IAC5E,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 678, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/convertCOSEtoPKCS.js"],"sourcesContent":["import { isoCBOR, isoUint8Array } from './iso/index.js';\nimport { COSEKEYS } from './cose.js';\n/**\n * Takes COSE-encoded public key and converts it to PKCS key\n */\nexport function convertCOSEtoPKCS(cosePublicKey) {\n    // This is a little sloppy, I'm using COSEPublicKeyEC2 since it could have both x and y, but when\n    // there's no y it means it's probably better typed as COSEPublicKeyOKP. I'll leave this for now\n    // and revisit it later if it ever becomes an actual problem.\n    const struct = isoCBOR.decodeFirst(cosePublicKey);\n    const tag = Uint8Array.from([0x04]);\n    const x = struct.get(COSEKEYS.x);\n    const y = struct.get(COSEKEYS.y);\n    if (!x) {\n        throw new Error('COSE public key was missing x');\n    }\n    if (y) {\n        return isoUint8Array.concat([tag, x, y]);\n    }\n    return isoUint8Array.concat([tag, x]);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AADA;AAAA;;;AAKO,SAAS,kBAAkB,aAAa;IAC3C,iGAAiG;IACjG,gGAAgG;IAChG,6DAA6D;IAC7D,MAAM,SAAS,2RAAA,CAAA,UAAO,CAAC,WAAW,CAAC;IACnC,MAAM,MAAM,WAAW,IAAI,CAAC;QAAC;KAAK;IAClC,MAAM,IAAI,OAAO,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IAC/B,MAAM,IAAI,OAAO,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IAC/B,IAAI,CAAC,GAAG;QACJ,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,GAAG;QACH,OAAO,uSAAA,CAAA,gBAAa,CAAC,MAAM,CAAC;YAAC;YAAK;YAAG;SAAE;IAC3C;IACA,OAAO,uSAAA,CAAA,gBAAa,CAAC,MAAM,CAAC;QAAC;QAAK;KAAE;AACxC","ignoreList":[0]}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/decodeAttestationObject.js"],"sourcesContent":["import { isoCBOR } from './iso/index.js';\n/**\n * Convert an AttestationObject buffer to a proper object\n *\n * @param base64AttestationObject Attestation Object buffer\n */\nexport function decodeAttestationObject(attestationObject) {\n    return _decodeAttestationObjectInternals.stubThis(isoCBOR.decodeFirst(attestationObject));\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _decodeAttestationObjectInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAMO,SAAS,wBAAwB,iBAAiB;IACrD,OAAO,kCAAkC,QAAQ,CAAC,2RAAA,CAAA,UAAO,CAAC,WAAW,CAAC;AAC1E;AAKO,MAAM,oCAAoC;IAC7C,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 747, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 753, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/decodeClientDataJSON.js"],"sourcesContent":["import { isoBase64URL } from './iso/index.js';\n/**\n * Decode an authenticator's base64url-encoded clientDataJSON to JSON\n */\nexport function decodeClientDataJSON(data) {\n    const toString = isoBase64URL.toUTF8String(data);\n    const clientData = JSON.parse(toString);\n    return _decodeClientDataJSONInternals.stubThis(clientData);\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _decodeClientDataJSONInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAIO,SAAS,qBAAqB,IAAI;IACrC,MAAM,WAAW,qSAAA,CAAA,eAAY,CAAC,YAAY,CAAC;IAC3C,MAAM,aAAa,KAAK,KAAK,CAAC;IAC9B,OAAO,+BAA+B,QAAQ,CAAC;AACnD;AAKO,MAAM,iCAAiC;IAC1C,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 768, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 774, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/decodeCredentialPublicKey.js"],"sourcesContent":["import { isoCBOR } from './iso/index.js';\nexport function decodeCredentialPublicKey(publicKey) {\n    return _decodeCredentialPublicKeyInternals.stubThis(isoCBOR.decodeFirst(publicKey));\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _decodeCredentialPublicKeyInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AACO,SAAS,0BAA0B,SAAS;IAC/C,OAAO,oCAAoC,QAAQ,CAAC,2RAAA,CAAA,UAAO,CAAC,WAAW,CAAC;AAC5E;AAKO,MAAM,sCAAsC;IAC/C,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 787, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 793, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/index.js"],"sourcesContent":["/**\n * A runtime-agnostic collection of methods for working with the WebCrypto API\n * @module\n */\nexport { digest } from './digest.js';\nexport { getRandomValues } from './getRandomValues.js';\nexport { verify } from './verify.js';\n"],"names":[],"mappings":"AAAA;;;CAGC","ignoreList":[0]}},
    {"offset": {"line": 800, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 844, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/generateUserID.js"],"sourcesContent":["import { isoCrypto } from './iso/index.js';\n/**\n * Generate a suitably random value to be used as user ID\n */\nexport async function generateUserID() {\n    /**\n     * WebAuthn spec says user.id has a max length of 64 bytes. I prefer how 32 random bytes look\n     * after they're base64url-encoded so I'm choosing to go with that here.\n     */\n    const newUserID = new Uint8Array(32);\n    await isoCrypto.getRandomValues(newUserID);\n    return _generateUserIDInternals.stubThis(newUserID);\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _generateUserIDInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAIO,eAAe;IAClB;;;KAGC,GACD,MAAM,YAAY,IAAI,WAAW;IACjC,MAAM,wSAAA,CAAA,YAAS,CAAC,eAAe,CAAC;IAChC,OAAO,yBAAyB,QAAQ,CAAC;AAC7C;AAKO,MAAM,2BAA2B;IACpC,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 862, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/getCertificateInfo.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { BasicConstraints, Certificate, id_ce_basicConstraints } from '@peculiar/asn1-x509';\nconst issuerSubjectIDKey = {\n    '2.5.4.6': 'C',\n    '2.5.4.10': 'O',\n    '2.5.4.11': 'OU',\n    '2.5.4.3': 'CN',\n};\n/**\n * Extract PEM certificate info\n *\n * @param pemCertificate Result from call to `convertASN1toPEM(x5c[0])`\n */\nexport function getCertificateInfo(leafCertBuffer) {\n    const x509 = AsnParser.parse(leafCertBuffer, Certificate);\n    const parsedCert = x509.tbsCertificate;\n    // Issuer\n    const issuer = { combined: '' };\n    parsedCert.issuer.forEach(([iss]) => {\n        const key = issuerSubjectIDKey[iss.type];\n        if (key) {\n            issuer[key] = iss.value.toString();\n        }\n    });\n    issuer.combined = issuerSubjectToString(issuer);\n    // Subject\n    const subject = { combined: '' };\n    parsedCert.subject.forEach(([iss]) => {\n        const key = issuerSubjectIDKey[iss.type];\n        if (key) {\n            subject[key] = iss.value.toString();\n        }\n    });\n    subject.combined = issuerSubjectToString(subject);\n    let basicConstraintsCA = false;\n    if (parsedCert.extensions) {\n        // console.log(parsedCert.extensions);\n        for (const ext of parsedCert.extensions) {\n            if (ext.extnID === id_ce_basicConstraints) {\n                const basicConstraints = AsnParser.parse(ext.extnValue, BasicConstraints);\n                basicConstraintsCA = basicConstraints.cA;\n            }\n        }\n    }\n    return {\n        issuer,\n        subject,\n        version: parsedCert.version,\n        basicConstraintsCA,\n        notBefore: parsedCert.validity.notBefore.getTime(),\n        notAfter: parsedCert.validity.notAfter.getTime(),\n        parsedCertificate: x509,\n    };\n}\n/**\n * Stringify the parts of Issuer or Subject info for easier comparison of subject issuers with\n * issuer subjects.\n *\n * The order might seem arbitrary, because it is. It should be enough that the two are stringified\n * in the same order.\n */\nfunction issuerSubjectToString(input) {\n    const parts = [];\n    if (input.C) {\n        parts.push(input.C);\n    }\n    if (input.O) {\n        parts.push(input.O);\n    }\n    if (input.OU) {\n        parts.push(input.OU);\n    }\n    if (input.CN) {\n        parts.push(input.CN);\n    }\n    return parts.join(' : ');\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AADA;AACA;AAAA;;;AACA,MAAM,qBAAqB;IACvB,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,WAAW;AACf;AAMO,SAAS,mBAAmB,cAAc;IAC7C,MAAM,OAAO,qPAAA,CAAA,YAAS,CAAC,KAAK,CAAC,gBAAgB,sPAAA,CAAA,cAAW;IACxD,MAAM,aAAa,KAAK,cAAc;IACtC,SAAS;IACT,MAAM,SAAS;QAAE,UAAU;IAAG;IAC9B,WAAW,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI;QAC5B,MAAM,MAAM,kBAAkB,CAAC,IAAI,IAAI,CAAC;QACxC,IAAI,KAAK;YACL,MAAM,CAAC,IAAI,GAAG,IAAI,KAAK,CAAC,QAAQ;QACpC;IACJ;IACA,OAAO,QAAQ,GAAG,sBAAsB;IACxC,UAAU;IACV,MAAM,UAAU;QAAE,UAAU;IAAG;IAC/B,WAAW,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI;QAC7B,MAAM,MAAM,kBAAkB,CAAC,IAAI,IAAI,CAAC;QACxC,IAAI,KAAK;YACL,OAAO,CAAC,IAAI,GAAG,IAAI,KAAK,CAAC,QAAQ;QACrC;IACJ;IACA,QAAQ,QAAQ,GAAG,sBAAsB;IACzC,IAAI,qBAAqB;IACzB,IAAI,WAAW,UAAU,EAAE;QACvB,sCAAsC;QACtC,KAAK,MAAM,OAAO,WAAW,UAAU,CAAE;YACrC,IAAI,IAAI,MAAM,KAAK,0QAAA,CAAA,yBAAsB,EAAE;gBACvC,MAAM,mBAAmB,qPAAA,CAAA,YAAS,CAAC,KAAK,CAAC,IAAI,SAAS,EAAE,0QAAA,CAAA,mBAAgB;gBACxE,qBAAqB,iBAAiB,EAAE;YAC5C;QACJ;IACJ;IACA,OAAO;QACH;QACA;QACA,SAAS,WAAW,OAAO;QAC3B;QACA,WAAW,WAAW,QAAQ,CAAC,SAAS,CAAC,OAAO;QAChD,UAAU,WAAW,QAAQ,CAAC,QAAQ,CAAC,OAAO;QAC9C,mBAAmB;IACvB;AACJ;AACA;;;;;;CAMC,GACD,SAAS,sBAAsB,KAAK;IAChC,MAAM,QAAQ,EAAE;IAChB,IAAI,MAAM,CAAC,EAAE;QACT,MAAM,IAAI,CAAC,MAAM,CAAC;IACtB;IACA,IAAI,MAAM,CAAC,EAAE;QACT,MAAM,IAAI,CAAC,MAAM,CAAC;IACtB;IACA,IAAI,MAAM,EAAE,EAAE;QACV,MAAM,IAAI,CAAC,MAAM,EAAE;IACvB;IACA,IAAI,MAAM,EAAE,EAAE;QACV,MAAM,IAAI,CAAC,MAAM,EAAE;IACvB;IACA,OAAO,MAAM,IAAI,CAAC;AACtB","ignoreList":[0]}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/fetch.js"],"sourcesContent":["/**\n * A simple method for requesting data via standard `fetch`. Should work\n * across multiple runtimes.\n */\nexport function fetch(url) {\n    return _fetchInternals.stubThis(url);\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _fetchInternals = {\n    stubThis: (url) => globalThis.fetch(url),\n};\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACM,SAAS,MAAM,GAAG;IACrB,OAAO,gBAAgB,QAAQ,CAAC;AACpC;AAKO,MAAM,kBAAkB;IAC3B,UAAU,CAAC,MAAQ,WAAW,KAAK,CAAC;AACxC","ignoreList":[0]}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 976, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/isCertRevoked.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { AuthorityKeyIdentifier, CertificateList, CRLDistributionPoints, id_ce_authorityKeyIdentifier, id_ce_cRLDistributionPoints, id_ce_subjectKeyIdentifier, SubjectKeyIdentifier, } from '@peculiar/asn1-x509';\nimport { isoUint8Array } from './iso/index.js';\nimport { fetch } from './fetch.js';\nconst cacheRevokedCerts = {};\n/**\n * A method to pull a CRL from a certificate and compare its serial number to the list of revoked\n * certificate serial numbers within the CRL.\n *\n * CRL certificate structure referenced from https://tools.ietf.org/html/rfc5280#page-117\n */\nexport async function isCertRevoked(cert) {\n    const { extensions } = cert.tbsCertificate;\n    if (!extensions) {\n        return false;\n    }\n    let extAuthorityKeyID;\n    let extSubjectKeyID;\n    let extCRLDistributionPoints;\n    extensions.forEach((ext) => {\n        if (ext.extnID === id_ce_authorityKeyIdentifier) {\n            extAuthorityKeyID = AsnParser.parse(ext.extnValue, AuthorityKeyIdentifier);\n        }\n        else if (ext.extnID === id_ce_subjectKeyIdentifier) {\n            extSubjectKeyID = AsnParser.parse(ext.extnValue, SubjectKeyIdentifier);\n        }\n        else if (ext.extnID === id_ce_cRLDistributionPoints) {\n            extCRLDistributionPoints = AsnParser.parse(ext.extnValue, CRLDistributionPoints);\n        }\n    });\n    // Check to see if we've got cached info for the cert's CA\n    let keyIdentifier = undefined;\n    if (extAuthorityKeyID && extAuthorityKeyID.keyIdentifier) {\n        keyIdentifier = isoUint8Array.toHex(new Uint8Array(extAuthorityKeyID.keyIdentifier.buffer));\n    }\n    else if (extSubjectKeyID) {\n        /**\n         * We might be dealing with a self-signed root certificate. Check the\n         * Subject key Identifier extension next.\n         */\n        keyIdentifier = isoUint8Array.toHex(new Uint8Array(extSubjectKeyID.buffer));\n    }\n    const certSerialHex = isoUint8Array.toHex(new Uint8Array(cert.tbsCertificate.serialNumber));\n    if (keyIdentifier) {\n        const cached = cacheRevokedCerts[keyIdentifier];\n        if (cached) {\n            const now = new Date();\n            // If there's a nextUpdate then make sure we're before it\n            if (!cached.nextUpdate || cached.nextUpdate > now) {\n                return cached.revokedCerts.indexOf(certSerialHex) >= 0;\n            }\n        }\n    }\n    const crlURL = extCRLDistributionPoints?.[0].distributionPoint?.fullName?.[0]\n        .uniformResourceIdentifier;\n    // If no URL is provided then we have nothing to check\n    if (!crlURL) {\n        return false;\n    }\n    // Download and read the CRL\n    let certListBytes;\n    try {\n        const respCRL = await fetch(crlURL);\n        certListBytes = await respCRL.arrayBuffer();\n    }\n    catch (_err) {\n        return false;\n    }\n    let data;\n    try {\n        data = AsnParser.parse(certListBytes, CertificateList);\n    }\n    catch (_err) {\n        // Something was malformed with the CRL, so pass\n        return false;\n    }\n    const newCached = {\n        revokedCerts: [],\n        nextUpdate: undefined,\n    };\n    // nextUpdate\n    if (data.tbsCertList.nextUpdate) {\n        newCached.nextUpdate = data.tbsCertList.nextUpdate.getTime();\n    }\n    // revokedCertificates\n    const revokedCerts = data.tbsCertList.revokedCertificates;\n    if (revokedCerts) {\n        for (const cert of revokedCerts) {\n            const revokedHex = isoUint8Array.toHex(new Uint8Array(cert.userCertificate));\n            newCached.revokedCerts.push(revokedHex);\n        }\n        // Cache the results\n        if (keyIdentifier) {\n            cacheRevokedCerts[keyIdentifier] = newCached;\n        }\n        return newCached.revokedCerts.indexOf(certSerialHex) >= 0;\n    }\n    return false;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1075, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1081, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/decodeAuthenticatorExtensions.js"],"sourcesContent":["import { isoCBOR } from './iso/index.js';\n/**\n * Convert authenticator extension data buffer to a proper object\n *\n * @param extensionData Authenticator Extension Data buffer\n */\nexport function decodeAuthenticatorExtensions(extensionData) {\n    let toCBOR;\n    try {\n        toCBOR = isoCBOR.decodeFirst(extensionData);\n    }\n    catch (err) {\n        const _err = err;\n        throw new Error(`Error decoding authenticator extensions: ${_err.message}`);\n    }\n    return convertMapToObjectDeep(toCBOR);\n}\n/**\n * CBOR-encoded extensions can be deeply-nested Maps, which are too deep for a simple\n * `Object.entries()`. This method will recursively make sure that all Maps are converted into\n * basic objects.\n */\nfunction convertMapToObjectDeep(input) {\n    const mapped = {};\n    for (const [key, value] of input) {\n        if (value instanceof Map) {\n            mapped[key] = convertMapToObjectDeep(value);\n        }\n        else {\n            mapped[key] = value;\n        }\n    }\n    return mapped;\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAMO,SAAS,8BAA8B,aAAa;IACvD,IAAI;IACJ,IAAI;QACA,SAAS,2RAAA,CAAA,UAAO,CAAC,WAAW,CAAC;IACjC,EACA,OAAO,KAAK;QACR,MAAM,OAAO;QACb,MAAM,IAAI,MAAM,CAAC,yCAAyC,EAAE,KAAK,OAAO,EAAE;IAC9E;IACA,OAAO,uBAAuB;AAClC;AACA;;;;CAIC,GACD,SAAS,uBAAuB,KAAK;IACjC,MAAM,SAAS,CAAC;IAChB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,MAAO;QAC9B,IAAI,iBAAiB,KAAK;YACtB,MAAM,CAAC,IAAI,GAAG,uBAAuB;QACzC,OACK;YACD,MAAM,CAAC,IAAI,GAAG;QAClB;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/parseAuthenticatorData.js"],"sourcesContent":["import { decodeAuthenticatorExtensions, } from './decodeAuthenticatorExtensions.js';\nimport { isoCBOR, isoUint8Array } from './iso/index.js';\n/**\n * Make sense of the authData buffer contained in an Attestation\n */\nexport function parseAuthenticatorData(authData) {\n    if (authData.byteLength < 37) {\n        throw new Error(`Authenticator data was ${authData.byteLength} bytes, expected at least 37 bytes`);\n    }\n    let pointer = 0;\n    const dataView = isoUint8Array.toDataView(authData);\n    const rpIdHash = authData.slice(pointer, pointer += 32);\n    const flagsBuf = authData.slice(pointer, pointer += 1);\n    const flagsInt = flagsBuf[0];\n    // Bit positions can be referenced here:\n    // https://www.w3.org/TR/webauthn-2/#flags\n    const flags = {\n        up: !!(flagsInt & (1 << 0)), // User Presence\n        uv: !!(flagsInt & (1 << 2)), // User Verified\n        be: !!(flagsInt & (1 << 3)), // Backup Eligibility\n        bs: !!(flagsInt & (1 << 4)), // Backup State\n        at: !!(flagsInt & (1 << 6)), // Attested Credential Data Present\n        ed: !!(flagsInt & (1 << 7)), // Extension Data Present\n        flagsInt,\n    };\n    const counterBuf = authData.slice(pointer, pointer + 4);\n    const counter = dataView.getUint32(pointer, false);\n    pointer += 4;\n    let aaguid = undefined;\n    let credentialID = undefined;\n    let credentialPublicKey = undefined;\n    if (flags.at) {\n        aaguid = authData.slice(pointer, pointer += 16);\n        const credIDLen = dataView.getUint16(pointer);\n        pointer += 2;\n        credentialID = authData.slice(pointer, pointer += credIDLen);\n        /**\n         * Firefox 117 incorrectly CBOR-encodes authData when EdDSA (-8) is used for the public key.\n         * A CBOR \"Map of 3 items\" (0xa3) should be \"Map of 4 items\" (0xa4), and if we manually adjust\n         * the single byte there's a good chance the authData can be correctly parsed.\n         *\n         * This browser release also incorrectly uses the string labels \"OKP\" and \"Ed25519\" instead of\n         * their integer representations for kty and crv respectively. That's why the COSE public key\n         * in the hex below looks so odd.\n         */\n        // Bytes decode to `{ 1: \"OKP\", 3: -8, -1: \"Ed25519\" }` (it's missing key -2 a.k.a. COSEKEYS.x)\n        const badEdDSACBOR = isoUint8Array.fromHex('a301634f4b500327206745643235353139');\n        const bytesAtCurrentPosition = authData.slice(pointer, pointer + badEdDSACBOR.byteLength);\n        let foundBadCBOR = false;\n        if (isoUint8Array.areEqual(badEdDSACBOR, bytesAtCurrentPosition)) {\n            // Change the bad CBOR 0xa3 to 0xa4 so that the credential public key can be recognized\n            foundBadCBOR = true;\n            authData[pointer] = 0xa4;\n        }\n        // Decode the next CBOR item in the buffer, then re-encode it back to a Buffer\n        const firstDecoded = isoCBOR.decodeFirst(authData.slice(pointer));\n        const firstEncoded = Uint8Array.from(\n        /**\n         * Casting to `Map` via `as unknown` here because TS doesn't make it possible to define Maps\n         * with discrete keys and properties with known types per pair, and CBOR libs typically parse\n         * CBOR Major Type 5 to `Map` because you can have numbers for keys. A `COSEPublicKey` can be\n         * generalized as \"a Map with numbers for keys and either numbers or bytes for values\" though.\n         * If this presumption falls apart then other parts of verification later on will fail so we\n         * should be safe doing this here.\n         */\n        isoCBOR.encode(firstDecoded));\n        if (foundBadCBOR) {\n            // Restore the bit we changed so that `authData` is the same as it came in and won't break\n            // signature verification.\n            authData[pointer] = 0xa3;\n        }\n        credentialPublicKey = firstEncoded;\n        pointer += firstEncoded.byteLength;\n    }\n    let extensionsData = undefined;\n    let extensionsDataBuffer = undefined;\n    if (flags.ed) {\n        const firstDecoded = isoCBOR.decodeFirst(authData.slice(pointer));\n        extensionsDataBuffer = Uint8Array.from(isoCBOR.encode(firstDecoded));\n        extensionsData = decodeAuthenticatorExtensions(extensionsDataBuffer);\n        pointer += extensionsDataBuffer.byteLength;\n    }\n    // Pointer should be at the end of the authenticator data, otherwise too much data was sent\n    if (authData.byteLength > pointer) {\n        throw new Error('Leftover bytes detected while parsing authenticator data');\n    }\n    return _parseAuthenticatorDataInternals.stubThis({\n        rpIdHash,\n        flagsBuf,\n        flags,\n        counter,\n        counterBuf,\n        aaguid,\n        credentialID,\n        credentialPublicKey,\n        extensionsData,\n        extensionsDataBuffer,\n    });\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _parseAuthenticatorDataInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;;;AAIO,SAAS,uBAAuB,QAAQ;IAC3C,IAAI,SAAS,UAAU,GAAG,IAAI;QAC1B,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,SAAS,UAAU,CAAC,kCAAkC,CAAC;IACrG;IACA,IAAI,UAAU;IACd,MAAM,WAAW,uSAAA,CAAA,gBAAa,CAAC,UAAU,CAAC;IAC1C,MAAM,WAAW,SAAS,KAAK,CAAC,SAAS,WAAW;IACpD,MAAM,WAAW,SAAS,KAAK,CAAC,SAAS,WAAW;IACpD,MAAM,WAAW,QAAQ,CAAC,EAAE;IAC5B,wCAAwC;IACxC,0CAA0C;IAC1C,MAAM,QAAQ;QACV,IAAI,CAAC,CAAC,CAAC,WAAY,KAAK,CAAE;QAC1B,IAAI,CAAC,CAAC,CAAC,WAAY,KAAK,CAAE;QAC1B,IAAI,CAAC,CAAC,CAAC,WAAY,KAAK,CAAE;QAC1B,IAAI,CAAC,CAAC,CAAC,WAAY,KAAK,CAAE;QAC1B,IAAI,CAAC,CAAC,CAAC,WAAY,KAAK,CAAE;QAC1B,IAAI,CAAC,CAAC,CAAC,WAAY,KAAK,CAAE;QAC1B;IACJ;IACA,MAAM,aAAa,SAAS,KAAK,CAAC,SAAS,UAAU;IACrD,MAAM,UAAU,SAAS,SAAS,CAAC,SAAS;IAC5C,WAAW;IACX,IAAI,SAAS;IACb,IAAI,eAAe;IACnB,IAAI,sBAAsB;IAC1B,IAAI,MAAM,EAAE,EAAE;QACV,SAAS,SAAS,KAAK,CAAC,SAAS,WAAW;QAC5C,MAAM,YAAY,SAAS,SAAS,CAAC;QACrC,WAAW;QACX,eAAe,SAAS,KAAK,CAAC,SAAS,WAAW;QAClD;;;;;;;;SAQC,GACD,+FAA+F;QAC/F,MAAM,eAAe,uSAAA,CAAA,gBAAa,CAAC,OAAO,CAAC;QAC3C,MAAM,yBAAyB,SAAS,KAAK,CAAC,SAAS,UAAU,aAAa,UAAU;QACxF,IAAI,eAAe;QACnB,IAAI,uSAAA,CAAA,gBAAa,CAAC,QAAQ,CAAC,cAAc,yBAAyB;YAC9D,uFAAuF;YACvF,eAAe;YACf,QAAQ,CAAC,QAAQ,GAAG;QACxB;QACA,8EAA8E;QAC9E,MAAM,eAAe,2RAAA,CAAA,UAAO,CAAC,WAAW,CAAC,SAAS,KAAK,CAAC;QACxD,MAAM,eAAe,WAAW,IAAI,CACpC;;;;;;;SAOC,GACD,2RAAA,CAAA,UAAO,CAAC,MAAM,CAAC;QACf,IAAI,cAAc;YACd,0FAA0F;YAC1F,0BAA0B;YAC1B,QAAQ,CAAC,QAAQ,GAAG;QACxB;QACA,sBAAsB;QACtB,WAAW,aAAa,UAAU;IACtC;IACA,IAAI,iBAAiB;IACrB,IAAI,uBAAuB;IAC3B,IAAI,MAAM,EAAE,EAAE;QACV,MAAM,eAAe,2RAAA,CAAA,UAAO,CAAC,WAAW,CAAC,SAAS,KAAK,CAAC;QACxD,uBAAuB,WAAW,IAAI,CAAC,2RAAA,CAAA,UAAO,CAAC,MAAM,CAAC;QACtD,iBAAiB,CAAA,GAAA,uQAAA,CAAA,gCAA6B,AAAD,EAAE;QAC/C,WAAW,qBAAqB,UAAU;IAC9C;IACA,2FAA2F;IAC3F,IAAI,SAAS,UAAU,GAAG,SAAS;QAC/B,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,iCAAiC,QAAQ,CAAC;QAC7C;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;AAKO,MAAM,mCAAmC;IAC5C,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 1222, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1228, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/toHash.js"],"sourcesContent":["import { isoCrypto, isoUint8Array } from './iso/index.js';\n/**\n * Returns hash digest of the given data, using the given algorithm when provided. Defaults to using\n * SHA-256.\n */\nexport function toHash(data, algorithm = -7) {\n    if (typeof data === 'string') {\n        data = isoUint8Array.fromUTF8String(data);\n    }\n    const digest = isoCrypto.digest(data, algorithm);\n    return digest;\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;AAAA;;AAKO,SAAS,OAAO,IAAI,EAAE,YAAY,CAAC,CAAC;IACvC,IAAI,OAAO,SAAS,UAAU;QAC1B,OAAO,uSAAA,CAAA,gBAAa,CAAC,cAAc,CAAC;IACxC;IACA,MAAM,SAAS,wSAAA,CAAA,YAAS,CAAC,MAAM,CAAC,MAAM;IACtC,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1242, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1248, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/mapX509SignatureAlgToCOSEAlg.js"],"sourcesContent":["import { COSEALG } from './cose.js';\n/**\n * Map X.509 signature algorithm OIDs to COSE algorithm IDs\n *\n * - EC2 OIDs: https://oidref.com/1.2.840.10045.4.3\n * - RSA OIDs: https://oidref.com/1.2.840.113549.1.1\n */\nexport function mapX509SignatureAlgToCOSEAlg(signatureAlgorithm) {\n    let alg;\n    if (signatureAlgorithm === '1.2.840.10045.4.3.2') {\n        alg = COSEALG.ES256;\n    }\n    else if (signatureAlgorithm === '1.2.840.10045.4.3.3') {\n        alg = COSEALG.ES384;\n    }\n    else if (signatureAlgorithm === '1.2.840.10045.4.3.4') {\n        alg = COSEALG.ES512;\n    }\n    else if (signatureAlgorithm === '1.2.840.113549.1.1.11') {\n        alg = COSEALG.RS256;\n    }\n    else if (signatureAlgorithm === '1.2.840.113549.1.1.12') {\n        alg = COSEALG.RS384;\n    }\n    else if (signatureAlgorithm === '1.2.840.113549.1.1.13') {\n        alg = COSEALG.RS512;\n    }\n    else if (signatureAlgorithm === '1.2.840.113549.1.1.5') {\n        alg = COSEALG.RS1;\n    }\n    else {\n        throw new Error(`Unable to map X.509 signature algorithm ${signatureAlgorithm} to a COSE algorithm`);\n    }\n    return alg;\n}\n"],"names":[],"mappings":";;;AAAA;;AAOO,SAAS,6BAA6B,kBAAkB;IAC3D,IAAI;IACJ,IAAI,uBAAuB,uBAAuB;QAC9C,MAAM,8OAAA,CAAA,UAAO,CAAC,KAAK;IACvB,OACK,IAAI,uBAAuB,uBAAuB;QACnD,MAAM,8OAAA,CAAA,UAAO,CAAC,KAAK;IACvB,OACK,IAAI,uBAAuB,uBAAuB;QACnD,MAAM,8OAAA,CAAA,UAAO,CAAC,KAAK;IACvB,OACK,IAAI,uBAAuB,yBAAyB;QACrD,MAAM,8OAAA,CAAA,UAAO,CAAC,KAAK;IACvB,OACK,IAAI,uBAAuB,yBAAyB;QACrD,MAAM,8OAAA,CAAA,UAAO,CAAC,KAAK;IACvB,OACK,IAAI,uBAAuB,yBAAyB;QACrD,MAAM,8OAAA,CAAA,UAAO,CAAC,KAAK;IACvB,OACK,IAAI,uBAAuB,wBAAwB;QACpD,MAAM,8OAAA,CAAA,UAAO,CAAC,GAAG;IACrB,OACK;QACD,MAAM,IAAI,MAAM,CAAC,wCAAwC,EAAE,mBAAmB,oBAAoB,CAAC;IACvG;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1274, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1280, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/convertX509PublicKeyToCOSE.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { Certificate } from '@peculiar/asn1-x509';\nimport { ECParameters, id_ecPublicKey, id_secp256r1, id_secp384r1 } from '@peculiar/asn1-ecc';\nimport { COSECRV, COSEKEYS, COSEKTY, } from './cose.js';\nimport { RSAPublicKey } from '@peculiar/asn1-rsa';\nimport { mapX509SignatureAlgToCOSEAlg } from './mapX509SignatureAlgToCOSEAlg.js';\nexport function convertX509PublicKeyToCOSE(x509Certificate) {\n    let cosePublicKey = new Map();\n    /**\n     * Time to extract the public key from an X.509 certificate\n     */\n    const x509 = AsnParser.parse(x509Certificate, Certificate);\n    const { tbsCertificate } = x509;\n    const { subjectPublicKeyInfo, signature: _tbsSignature } = tbsCertificate;\n    const signatureAlgorithm = _tbsSignature.algorithm;\n    const publicKeyAlgorithmID = subjectPublicKeyInfo.algorithm.algorithm;\n    if (publicKeyAlgorithmID === id_ecPublicKey) {\n        /**\n         * EC2 Public Key\n         */\n        if (!subjectPublicKeyInfo.algorithm.parameters) {\n            throw new Error('Certificate public key was missing parameters (EC2)');\n        }\n        const ecParameters = AsnParser.parse(new Uint8Array(subjectPublicKeyInfo.algorithm.parameters), ECParameters);\n        let crv = -999;\n        const { namedCurve } = ecParameters;\n        if (namedCurve === id_secp256r1) {\n            crv = COSECRV.P256;\n        }\n        else if (namedCurve === id_secp384r1) {\n            crv = COSECRV.P384;\n        }\n        else {\n            throw new Error(`Certificate public key contained unexpected namedCurve ${namedCurve} (EC2)`);\n        }\n        const subjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);\n        let x;\n        let y;\n        if (subjectPublicKey[0] === 0x04) {\n            // Public key is in \"uncompressed form\", so we can split the remaining bytes in half\n            let pointer = 1;\n            const halfLength = (subjectPublicKey.length - 1) / 2;\n            x = subjectPublicKey.slice(pointer, pointer += halfLength);\n            y = subjectPublicKey.slice(pointer);\n        }\n        else {\n            throw new Error('TODO: Figure out how to handle public keys in \"compressed form\"');\n        }\n        const coseEC2PubKey = new Map();\n        coseEC2PubKey.set(COSEKEYS.kty, COSEKTY.EC2);\n        coseEC2PubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));\n        coseEC2PubKey.set(COSEKEYS.crv, crv);\n        coseEC2PubKey.set(COSEKEYS.x, x);\n        coseEC2PubKey.set(COSEKEYS.y, y);\n        cosePublicKey = coseEC2PubKey;\n    }\n    else if (publicKeyAlgorithmID === '1.2.840.113549.1.1.1') {\n        /**\n         * RSA public key\n         */\n        const rsaPublicKey = AsnParser.parse(subjectPublicKeyInfo.subjectPublicKey, RSAPublicKey);\n        const coseRSAPubKey = new Map();\n        coseRSAPubKey.set(COSEKEYS.kty, COSEKTY.RSA);\n        coseRSAPubKey.set(COSEKEYS.alg, mapX509SignatureAlgToCOSEAlg(signatureAlgorithm));\n        coseRSAPubKey.set(COSEKEYS.n, new Uint8Array(rsaPublicKey.modulus));\n        coseRSAPubKey.set(COSEKEYS.e, new Uint8Array(rsaPublicKey.publicExponent));\n        cosePublicKey = coseRSAPubKey;\n    }\n    else {\n        throw new Error(`Certificate public key contained unexpected algorithm ID ${publicKeyAlgorithmID}`);\n    }\n    return cosePublicKey;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1359, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1365, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/verifySignature.js"],"sourcesContent":["import { isoCrypto } from './iso/index.js';\nimport { decodeCredentialPublicKey } from './decodeCredentialPublicKey.js';\nimport { convertX509PublicKeyToCOSE } from './convertX509PublicKeyToCOSE.js';\n/**\n * Verify an authenticator's signature\n */\nexport function verifySignature(opts) {\n    const { signature, data, credentialPublicKey, x509Certificate, hashAlgorithm, } = opts;\n    if (!x509Certificate && !credentialPublicKey) {\n        throw new Error('Must declare either \"leafCert\" or \"credentialPublicKey\"');\n    }\n    if (x509Certificate && credentialPublicKey) {\n        throw new Error('Must not declare both \"leafCert\" and \"credentialPublicKey\"');\n    }\n    let cosePublicKey = new Map();\n    if (credentialPublicKey) {\n        cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);\n    }\n    else if (x509Certificate) {\n        cosePublicKey = convertX509PublicKeyToCOSE(x509Certificate);\n    }\n    return _verifySignatureInternals.stubThis(isoCrypto.verify({\n        cosePublicKey,\n        signature,\n        data,\n        shaHashOverride: hashAlgorithm,\n    }));\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _verifySignatureInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAFA;;;;AAMO,SAAS,gBAAgB,IAAI;IAChC,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,mBAAmB,EAAE,eAAe,EAAE,aAAa,EAAG,GAAG;IAClF,IAAI,CAAC,mBAAmB,CAAC,qBAAqB;QAC1C,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,mBAAmB,qBAAqB;QACxC,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,gBAAgB,IAAI;IACxB,IAAI,qBAAqB;QACrB,gBAAgB,CAAA,GAAA,mQAAA,CAAA,4BAAyB,AAAD,EAAE;IAC9C,OACK,IAAI,iBAAiB;QACtB,gBAAgB,CAAA,GAAA,oQAAA,CAAA,6BAA0B,AAAD,EAAE;IAC/C;IACA,OAAO,0BAA0B,QAAQ,CAAC,wSAAA,CAAA,YAAS,CAAC,MAAM,CAAC;QACvD;QACA;QACA;QACA,iBAAiB;IACrB;AACJ;AAKO,MAAM,4BAA4B;IACrC,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 1400, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1406, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/convertPEMToBytes.js"],"sourcesContent":["import { isoBase64URL } from './iso/index.js';\n/**\n * Take a certificate in PEM format and convert it to bytes\n */\nexport function convertPEMToBytes(pem) {\n    const certBase64 = pem\n        .replace('-----BEGIN CERTIFICATE-----', '')\n        .replace('-----END CERTIFICATE-----', '')\n        .replace(/[\\n ]/g, '');\n    return isoBase64URL.toBuffer(certBase64, 'base64');\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAIO,SAAS,kBAAkB,GAAG;IACjC,MAAM,aAAa,IACd,OAAO,CAAC,+BAA+B,IACvC,OAAO,CAAC,6BAA6B,IACrC,OAAO,CAAC,UAAU;IACvB,OAAO,qSAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,YAAY;AAC7C","ignoreList":[0]}},
    {"offset": {"line": 1416, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1422, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/validateCertificatePath.js"],"sourcesContent":["import { AsnSerializer } from '@peculiar/asn1-schema';\nimport { isCertRevoked } from './isCertRevoked.js';\nimport { verifySignature } from './verifySignature.js';\nimport { mapX509SignatureAlgToCOSEAlg } from './mapX509SignatureAlgToCOSEAlg.js';\nimport { getCertificateInfo } from './getCertificateInfo.js';\nimport { convertPEMToBytes } from './convertPEMToBytes.js';\n/**\n * Traverse an array of PEM certificates and ensure they form a proper chain\n * @param x5cCertsPEM Typically the result of `x5c.map(convertASN1toPEM)`\n * @param trustAnchorsPEM PEM-formatted certs that an attestation statement x5c may chain back to\n */\nexport async function validateCertificatePath(x5cCertsPEM, trustAnchorsPEM = []) {\n    if (trustAnchorsPEM.length === 0) {\n        // We have no trust anchors to chain back to, so skip path validation\n        return true;\n    }\n    let invalidSubjectAndIssuerError = false;\n    let certificateNotYetValidOrExpiredErrorMessage = undefined;\n    for (const anchorPEM of trustAnchorsPEM) {\n        try {\n            const certsWithTrustAnchor = x5cCertsPEM.concat([anchorPEM]);\n            await _validatePath(certsWithTrustAnchor);\n            // If we successfully validated a path then there's no need to continue. Reset any existing\n            // errors that were thrown by earlier trust anchors\n            invalidSubjectAndIssuerError = false;\n            certificateNotYetValidOrExpiredErrorMessage = undefined;\n            break;\n        }\n        catch (err) {\n            if (err instanceof InvalidSubjectAndIssuer) {\n                invalidSubjectAndIssuerError = true;\n            }\n            else if (err instanceof CertificateNotYetValidOrExpired) {\n                certificateNotYetValidOrExpiredErrorMessage = err.message;\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    // We tried multiple trust anchors and none of them worked\n    if (invalidSubjectAndIssuerError) {\n        throw new InvalidSubjectAndIssuer();\n    }\n    else if (certificateNotYetValidOrExpiredErrorMessage) {\n        throw new CertificateNotYetValidOrExpired(certificateNotYetValidOrExpiredErrorMessage);\n    }\n    return true;\n}\n/**\n * @param x5cCerts X.509 `x5c` certs in PEM string format\n * @param anchorCert X.509 trust anchor cert in PEM string format\n */\nasync function _validatePath(x5cCertsWithTrustAnchorPEM) {\n    if (new Set(x5cCertsWithTrustAnchorPEM).size !== x5cCertsWithTrustAnchorPEM.length) {\n        throw new Error('Invalid certificate path: found duplicate certificates');\n    }\n    // Make sure no certs are revoked, and all are within their time validity window\n    for (const certificatePEM of x5cCertsWithTrustAnchorPEM) {\n        const certInfo = getCertificateInfo(convertPEMToBytes(certificatePEM));\n        await assertCertNotRevoked(certInfo.parsedCertificate);\n        assertCertIsWithinValidTimeWindow(certInfo, certificatePEM);\n    }\n    // Make sure each x5c cert is issued by the next certificate in the chain\n    for (let i = 0; i < (x5cCertsWithTrustAnchorPEM.length - 1); i += 1) {\n        const subjectPem = x5cCertsWithTrustAnchorPEM[i];\n        const issuerPem = x5cCertsWithTrustAnchorPEM[i + 1];\n        const subjectInfo = getCertificateInfo(convertPEMToBytes(subjectPem));\n        const issuerInfo = getCertificateInfo(convertPEMToBytes(issuerPem));\n        // Make sure subject issuer is issuer subject\n        if (subjectInfo.issuer.combined !== issuerInfo.subject.combined) {\n            throw new InvalidSubjectAndIssuer();\n        }\n        const issuerCertIsRootCert = issuerInfo.issuer.combined === issuerInfo.subject.combined;\n        await assertSubjectIsSignedByIssuer(subjectInfo.parsedCertificate, issuerPem);\n        // Perform one final check if the issuer cert is also a root certificate\n        if (issuerCertIsRootCert) {\n            await assertSubjectIsSignedByIssuer(issuerInfo.parsedCertificate, issuerPem);\n        }\n    }\n    return true;\n}\n/**\n * Check if the certificate is revoked or not. If it is, raise an error\n */\nasync function assertCertNotRevoked(certificate) {\n    // Check for certificate revocation\n    const subjectCertRevoked = await isCertRevoked(certificate);\n    if (subjectCertRevoked) {\n        throw new Error(`Found revoked certificate in certificate path`);\n    }\n}\n/**\n * Require the cert to be within its notBefore and notAfter time window\n *\n * @param certInfo Parsed cert information\n * @param certPEM PEM-formatted certificate, for error reporting\n */\nfunction assertCertIsWithinValidTimeWindow(certInfo, certPEM) {\n    const { notBefore, notAfter } = certInfo;\n    const now = new Date(Date.now());\n    if (notBefore > now || notAfter < now) {\n        throw new CertificateNotYetValidOrExpired(`Certificate is not yet valid or expired: ${certPEM}`);\n    }\n}\n/**\n * Ensure that the subject cert has been signed by the next cert in the chain\n */\nasync function assertSubjectIsSignedByIssuer(subjectCert, issuerPEM) {\n    // Verify the subject certificate's signature with the issuer cert's public key\n    const data = AsnSerializer.serialize(subjectCert.tbsCertificate);\n    const signature = subjectCert.signatureValue;\n    const signatureAlgorithm = mapX509SignatureAlgToCOSEAlg(subjectCert.signatureAlgorithm.algorithm);\n    const issuerCertBytes = convertPEMToBytes(issuerPEM);\n    const verified = await verifySignature({\n        data: new Uint8Array(data),\n        signature: new Uint8Array(signature),\n        x509Certificate: issuerCertBytes,\n        hashAlgorithm: signatureAlgorithm,\n    });\n    if (!verified) {\n        throw new InvalidSubjectSignatureForIssuer();\n    }\n}\n// Custom errors to help pass on certain errors\nclass InvalidSubjectAndIssuer extends Error {\n    constructor() {\n        const message = 'Subject issuer did not match issuer subject';\n        super(message);\n        this.name = 'InvalidSubjectAndIssuer';\n    }\n}\nclass InvalidSubjectSignatureForIssuer extends Error {\n    constructor() {\n        const message = 'Subject signature was invalid for issuer';\n        super(message);\n        this.name = 'InvalidSubjectSignatureForIssuer';\n    }\n}\nclass CertificateNotYetValidOrExpired extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'CertificateNotYetValidOrExpired';\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1566, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1572, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 1589, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1619, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/verifyOKP.js"],"sourcesContent":["import { COSECRV, COSEKEYS, isCOSEAlg } from '../../cose.js';\nimport { isoBase64URL } from '../../index.js';\nimport { importKey } from './importKey.js';\nimport { getWebCrypto } from './getWebCrypto.js';\nexport async function verifyOKP(opts) {\n    const { cosePublicKey, signature, data } = opts;\n    const WebCrypto = await getWebCrypto();\n    const alg = cosePublicKey.get(COSEKEYS.alg);\n    const crv = cosePublicKey.get(COSEKEYS.crv);\n    const x = cosePublicKey.get(COSEKEYS.x);\n    if (!alg) {\n        throw new Error('Public key was missing alg (OKP)');\n    }\n    if (!isCOSEAlg(alg)) {\n        throw new Error(`Public key had invalid alg ${alg} (OKP)`);\n    }\n    if (!crv) {\n        throw new Error('Public key was missing crv (OKP)');\n    }\n    if (!x) {\n        throw new Error('Public key was missing x (OKP)');\n    }\n    // Pulled key import steps from here:\n    // https://wicg.github.io/webcrypto-secure-curves/#ed25519-operations\n    let _crv;\n    if (crv === COSECRV.ED25519) {\n        _crv = 'Ed25519';\n    }\n    else {\n        throw new Error(`Unexpected COSE crv value of ${crv} (OKP)`);\n    }\n    const keyData = {\n        kty: 'OKP',\n        crv: _crv,\n        alg: 'EdDSA',\n        x: isoBase64URL.fromBuffer(x),\n        ext: false,\n    };\n    const keyAlgorithm = {\n        name: _crv,\n        namedCurve: _crv,\n    };\n    const key = await importKey({\n        keyData,\n        algorithm: keyAlgorithm,\n    });\n    const verifyAlgorithm = {\n        name: _crv,\n    };\n    return WebCrypto.subtle.verify(verifyAlgorithm, key, signature, data);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAFA;;;;;AAGO,eAAe,UAAU,IAAI;IAChC,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG;IAC3C,MAAM,YAAY,MAAM,CAAA,GAAA,0QAAA,CAAA,eAAY,AAAD;IACnC,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IAC1C,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IAC1C,MAAM,IAAI,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,CAAC;IACtC,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,CAAA,GAAA,8OAAA,CAAA,YAAS,AAAD,EAAE,MAAM;QACjB,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,IAAI,MAAM,CAAC;IAC7D;IACA,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,GAAG;QACJ,MAAM,IAAI,MAAM;IACpB;IACA,qCAAqC;IACrC,qEAAqE;IACrE,IAAI;IACJ,IAAI,QAAQ,8OAAA,CAAA,UAAO,CAAC,OAAO,EAAE;QACzB,OAAO;IACX,OACK;QACD,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,IAAI,MAAM,CAAC;IAC/D;IACA,MAAM,UAAU;QACZ,KAAK;QACL,KAAK;QACL,KAAK;QACL,GAAG,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC;QAC3B,KAAK;IACT;IACA,MAAM,eAAe;QACjB,MAAM;QACN,YAAY;IAChB;IACA,MAAM,MAAM,MAAM,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;QACxB;QACA,WAAW;IACf;IACA,MAAM,kBAAkB;QACpB,MAAM;IACV;IACA,OAAO,UAAU,MAAM,CAAC,MAAM,CAAC,iBAAiB,KAAK,WAAW;AACpE","ignoreList":[0]}},
    {"offset": {"line": 1677, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1683, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/unwrapEC2Signature.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { ECDSASigValue } from '@peculiar/asn1-ecc';\nimport { COSECRV } from '../../cose.js';\nimport { isoUint8Array } from '../index.js';\n/**\n * In WebAuthn, EC2 signatures are wrapped in ASN.1 structure so we need to peel r and s apart.\n *\n * See https://www.w3.org/TR/webauthn-2/#sctn-signature-attestation-types\n */\nexport function unwrapEC2Signature(signature, crv) {\n    const parsedSignature = AsnParser.parse(signature, ECDSASigValue);\n    const rBytes = new Uint8Array(parsedSignature.r);\n    const sBytes = new Uint8Array(parsedSignature.s);\n    const componentLength = getSignatureComponentLength(crv);\n    const rNormalizedBytes = toNormalizedBytes(rBytes, componentLength);\n    const sNormalizedBytes = toNormalizedBytes(sBytes, componentLength);\n    const finalSignature = isoUint8Array.concat([\n        rNormalizedBytes,\n        sNormalizedBytes,\n    ]);\n    return finalSignature;\n}\n/**\n * The SubtleCrypto Web Crypto API expects ECDSA signatures with `r` and `s` values to be encoded\n * to a specific length depending on the order of the curve. This function returns the expected\n * byte-length for each of the `r` and `s` signature components.\n *\n * See <https://www.w3.org/TR/WebCryptoAPI/#ecdsa-operations>\n */\nfunction getSignatureComponentLength(crv) {\n    switch (crv) {\n        case COSECRV.P256:\n            return 32;\n        case COSECRV.P384:\n            return 48;\n        case COSECRV.P521:\n            return 66;\n        default:\n            throw new Error(`Unexpected COSE crv value of ${crv} (EC2)`);\n    }\n}\n/**\n * Converts the ASN.1 integer representation to bytes of a specific length `n`.\n *\n * DER encodes integers as big-endian byte arrays, with as small as possible representation and\n * requires a leading `0` byte to disambiguate between negative and positive numbers. This means\n * that `r` and `s` can potentially not be the expected byte-length that is needed by the\n * SubtleCrypto Web Crypto API: if there are leading `0`s it can be shorter than expected, and if\n * it has a leading `1` bit, it can be one byte longer.\n *\n * See <https://www.itu.int/rec/T-REC-X.690-202102-I/en>\n * See <https://www.w3.org/TR/WebCryptoAPI/#ecdsa-operations>\n */\nfunction toNormalizedBytes(bytes, componentLength) {\n    let normalizedBytes;\n    if (bytes.length < componentLength) {\n        // In case the bytes are shorter than expected, we need to pad it with leading `0`s.\n        normalizedBytes = new Uint8Array(componentLength);\n        normalizedBytes.set(bytes, componentLength - bytes.length);\n    }\n    else if (bytes.length === componentLength) {\n        normalizedBytes = bytes;\n    }\n    else if (bytes.length === componentLength + 1 && bytes[0] === 0 && (bytes[1] & 0x80) === 0x80) {\n        // The bytes contain a leading `0` to encode that the integer is positive. This leading `0`\n        // needs to be removed for compatibility with the SubtleCrypto Web Crypto API.\n        normalizedBytes = bytes.subarray(1);\n    }\n    else {\n        throw new Error(`Invalid signature component length ${bytes.length}, expected ${componentLength}`);\n    }\n    return normalizedBytes;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAHA;AACA;AAEA;;;;;AAMO,SAAS,mBAAmB,SAAS,EAAE,GAAG;IAC7C,MAAM,kBAAkB,qPAAA,CAAA,YAAS,CAAC,KAAK,CAAC,WAAW,2PAAA,CAAA,gBAAa;IAChE,MAAM,SAAS,IAAI,WAAW,gBAAgB,CAAC;IAC/C,MAAM,SAAS,IAAI,WAAW,gBAAgB,CAAC;IAC/C,MAAM,kBAAkB,4BAA4B;IACpD,MAAM,mBAAmB,kBAAkB,QAAQ;IACnD,MAAM,mBAAmB,kBAAkB,QAAQ;IACnD,MAAM,iBAAiB,uSAAA,CAAA,gBAAa,CAAC,MAAM,CAAC;QACxC;QACA;KACH;IACD,OAAO;AACX;AACA;;;;;;CAMC,GACD,SAAS,4BAA4B,GAAG;IACpC,OAAQ;QACJ,KAAK,8OAAA,CAAA,UAAO,CAAC,IAAI;YACb,OAAO;QACX,KAAK,8OAAA,CAAA,UAAO,CAAC,IAAI;YACb,OAAO;QACX,KAAK,8OAAA,CAAA,UAAO,CAAC,IAAI;YACb,OAAO;QACX;YACI,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,IAAI,MAAM,CAAC;IACnE;AACJ;AACA;;;;;;;;;;;CAWC,GACD,SAAS,kBAAkB,KAAK,EAAE,eAAe;IAC7C,IAAI;IACJ,IAAI,MAAM,MAAM,GAAG,iBAAiB;QAChC,oFAAoF;QACpF,kBAAkB,IAAI,WAAW;QACjC,gBAAgB,GAAG,CAAC,OAAO,kBAAkB,MAAM,MAAM;IAC7D,OACK,IAAI,MAAM,MAAM,KAAK,iBAAiB;QACvC,kBAAkB;IACtB,OACK,IAAI,MAAM,MAAM,KAAK,kBAAkB,KAAK,KAAK,CAAC,EAAE,KAAK,KAAK,CAAC,KAAK,CAAC,EAAE,GAAG,IAAI,MAAM,MAAM;QAC3F,2FAA2F;QAC3F,8EAA8E;QAC9E,kBAAkB,MAAM,QAAQ,CAAC;IACrC,OACK;QACD,MAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,MAAM,MAAM,CAAC,WAAW,EAAE,iBAAiB;IACrG;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1756, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1762, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/isoCrypto/verify.js"],"sourcesContent":["import { COSEKEYS, isCOSECrv, isCOSEPublicKeyEC2, isCOSEPublicKeyOKP, isCOSEPublicKeyRSA, } from '../../cose.js';\nimport { verifyEC2 } from './verifyEC2.js';\nimport { verifyRSA } from './verifyRSA.js';\nimport { verifyOKP } from './verifyOKP.js';\nimport { unwrapEC2Signature } from './unwrapEC2Signature.js';\n/**\n * Verify signatures with their public key. Supports EC2 and RSA public keys.\n */\nexport function verify(opts) {\n    const { cosePublicKey, signature, data, shaHashOverride } = opts;\n    if (isCOSEPublicKeyEC2(cosePublicKey)) {\n        const crv = cosePublicKey.get(COSEKEYS.crv);\n        if (!isCOSECrv(crv)) {\n            throw new Error(`unknown COSE curve ${crv}`);\n        }\n        const unwrappedSignature = unwrapEC2Signature(signature, crv);\n        return verifyEC2({\n            cosePublicKey,\n            signature: unwrappedSignature,\n            data,\n            shaHashOverride,\n        });\n    }\n    else if (isCOSEPublicKeyRSA(cosePublicKey)) {\n        return verifyRSA({ cosePublicKey, signature, data, shaHashOverride });\n    }\n    else if (isCOSEPublicKeyOKP(cosePublicKey)) {\n        return verifyOKP({ cosePublicKey, signature, data });\n    }\n    const kty = cosePublicKey.get(COSEKEYS.kty);\n    throw new Error(`Signature verification with public key of kty ${kty} is not supported by this method`);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAIO,SAAS,OAAO,IAAI;IACvB,MAAM,EAAE,aAAa,EAAE,SAAS,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG;IAC5D,IAAI,CAAA,GAAA,8OAAA,CAAA,qBAAkB,AAAD,EAAE,gBAAgB;QACnC,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;QAC1C,IAAI,CAAC,CAAA,GAAA,8OAAA,CAAA,YAAS,AAAD,EAAE,MAAM;YACjB,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE,KAAK;QAC/C;QACA,MAAM,qBAAqB,CAAA,GAAA,gRAAA,CAAA,qBAAkB,AAAD,EAAE,WAAW;QACzD,OAAO,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;YACb;YACA,WAAW;YACX;YACA;QACJ;IACJ,OACK,IAAI,CAAA,GAAA,8OAAA,CAAA,qBAAkB,AAAD,EAAE,gBAAgB;QACxC,OAAO,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;YAAE;YAAe;YAAW;YAAM;QAAgB;IACvE,OACK,IAAI,CAAA,GAAA,8OAAA,CAAA,qBAAkB,AAAD,EAAE,gBAAgB;QACxC,OAAO,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;YAAE;YAAe;YAAW;QAAK;IACtD;IACA,MAAM,MAAM,cAAc,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IAC1C,MAAM,IAAI,MAAM,CAAC,8CAA8C,EAAE,IAAI,gCAAgC,CAAC;AAC1G","ignoreList":[0]}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1823, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/iso/index.js"],"sourcesContent":["/**\n * A collection of methods for isomorphic manipulation of trickier data types\n *\n * The goal with these is to make it easier to replace dependencies later that might not play well\n * with specific server-like runtimes that expose global Web APIs (CloudFlare Workers, Deno, Bun,\n * etc...), while also supporting execution in Node.\n */\nexport * as isoBase64URL from './isoBase64URL.js';\nexport * as isoCBOR from './isoCBOR.js';\nexport * as isoCrypto from './isoCrypto/index.js';\nexport * as isoUint8Array from './isoUint8Array.js';\n"],"names":[],"mappings":"AAAA;;;;;;CAMC","ignoreList":[0]}},
    {"offset": {"line": 1834, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1852, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/generateChallenge.js"],"sourcesContent":["import { isoCrypto } from './iso/index.js';\n/**\n * Generate a suitably random value to be used as an attestation or assertion challenge\n */\nexport async function generateChallenge() {\n    /**\n     * WebAuthn spec says that 16 bytes is a good minimum:\n     *\n     * \"In order to prevent replay attacks, the challenges MUST contain enough entropy to make\n     * guessing them infeasible. Challenges SHOULD therefore be at least 16 bytes long.\"\n     *\n     * Just in case, let's double it\n     */\n    const challenge = new Uint8Array(32);\n    await isoCrypto.getRandomValues(challenge);\n    return _generateChallengeInternals.stubThis(challenge);\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _generateChallengeInternals = {\n    stubThis: (value) => value,\n};\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAIO,eAAe;IAClB;;;;;;;KAOC,GACD,MAAM,YAAY,IAAI,WAAW;IACjC,MAAM,wSAAA,CAAA,YAAS,CAAC,eAAe,CAAC;IAChC,OAAO,4BAA4B,QAAQ,CAAC;AAChD;AAKO,MAAM,8BAA8B;IACvC,UAAU,CAAC,QAAU;AACzB","ignoreList":[0]}},
    {"offset": {"line": 1874, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1880, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/generateRegistrationOptions.js"],"sourcesContent":["import { generateChallenge } from '../helpers/generateChallenge.js';\nimport { generateUserID } from '../helpers/generateUserID.js';\nimport { isoBase64URL, isoUint8Array } from '../helpers/iso/index.js';\n/**\n * Supported crypto algo identifiers\n * See https://w3c.github.io/webauthn/#sctn-alg-identifier\n * and https://www.iana.org/assignments/cose/cose.xhtml#algorithms\n */\nexport const supportedCOSEAlgorithmIdentifiers = [\n    // EdDSA (In first position to encourage authenticators to use this over ES256)\n    -8,\n    // ECDSA w/ SHA-256\n    -7,\n    // ECDSA w/ SHA-512\n    -36,\n    // RSASSA-PSS w/ SHA-256\n    -37,\n    // RSASSA-PSS w/ SHA-384\n    -38,\n    // RSASSA-PSS w/ SHA-512\n    -39,\n    // RSASSA-PKCS1-v1_5 w/ SHA-256\n    -257,\n    // RSASSA-PKCS1-v1_5 w/ SHA-384\n    -258,\n    // RSASSA-PKCS1-v1_5 w/ SHA-512\n    -259,\n    // RSASSA-PKCS1-v1_5 w/ SHA-1 (Deprecated; here for legacy support)\n    -65535,\n];\n/**\n * Set up some default authenticator selection options as per the latest spec:\n * https://www.w3.org/TR/webauthn-2/#dictdef-authenticatorselectioncriteria\n *\n * Helps with some older platforms (e.g. Android 7.0 Nougat) that may not be aware of these\n * defaults.\n */\nconst defaultAuthenticatorSelection = {\n    residentKey: 'preferred',\n    userVerification: 'preferred',\n};\n/**\n * Use the most commonly-supported algorithms\n * See the following:\n *   - https://www.iana.org/assignments/cose/cose.xhtml#algorithms\n *   - https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-pubkeycredparams\n */\nconst defaultSupportedAlgorithmIDs = [-8, -7, -257];\n/**\n * Prepare a value to pass into navigator.credentials.create(...) for authenticator registration\n *\n * **Options:**\n *\n * @param rpName - User-visible, \"friendly\" website/service name\n * @param rpID - Valid domain name (after `https://`)\n * @param userName - User's website-specific username (email, etc...)\n * @param userID **(Optional)** - User's website-specific unique ID. Defaults to generating a random identifier\n * @param challenge **(Optional)** - Random value the authenticator needs to sign and pass back. Defaults to generating a random value\n * @param userDisplayName **(Optional)** - User's actual name. Defaults to `\"\"`\n * @param timeout **(Optional)** - How long (in ms) the user can take to complete attestation. Defaults to `60000`\n * @param attestationType **(Optional)** - Specific attestation statement. Defaults to `\"none\"`\n * @param excludeCredentials **(Optional)** - Authenticators registered by the user so the user can't register the same credential multiple times. Defaults to `[]`\n * @param authenticatorSelection **(Optional)** - Advanced criteria for restricting the types of authenticators that may be used. Defaults to `{ residentKey: 'preferred', userVerification: 'preferred' }`\n * @param extensions **(Optional)** - Additional plugins the authenticator or browser should use during attestation\n * @param supportedAlgorithmIDs **(Optional)** - Array of numeric COSE algorithm identifiers supported for attestation by this RP. See https://www.iana.org/assignments/cose/cose.xhtml#algorithms. Defaults to `[-8, -7, -257]`\n * @param preferredAuthenticatorType **(Optional)** - Encourage the browser to prompt the user to register a specific type of authenticator\n */\nexport async function generateRegistrationOptions(options) {\n    const { rpName, rpID, userName, userID, challenge = await generateChallenge(), userDisplayName = '', timeout = 60000, attestationType = 'none', excludeCredentials = [], authenticatorSelection = defaultAuthenticatorSelection, extensions, supportedAlgorithmIDs = defaultSupportedAlgorithmIDs, preferredAuthenticatorType, } = options;\n    /**\n     * Prepare pubKeyCredParams from the array of algorithm ID's\n     */\n    const pubKeyCredParams = supportedAlgorithmIDs.map((id) => ({\n        alg: id,\n        type: 'public-key',\n    }));\n    /**\n     * Capture some of the nuances of how `residentKey` and `requireResidentKey` how either is set\n     * depending on when either is defined in the options\n     */\n    if (authenticatorSelection.residentKey === undefined) {\n        /**\n         * `residentKey`: \"If no value is given then the effective value is `required` if\n         * requireResidentKey is true or `discouraged` if it is false or absent.\"\n         *\n         * See https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-residentkey\n         */\n        if (authenticatorSelection.requireResidentKey) {\n            authenticatorSelection.residentKey = 'required';\n        }\n        else {\n            /**\n             * FIDO Conformance v1.7.2 fails the first test if we do this, even though this is\n             * technically compatible with the WebAuthn L2 spec...\n             */\n            // authenticatorSelection.residentKey = 'discouraged';\n        }\n    }\n    else {\n        /**\n         * `requireResidentKey`: \"Relying Parties SHOULD set it to true if, and only if, residentKey is\n         * set to \"required\"\"\n         *\n         * Spec says this property defaults to `false` so we should still be okay to assign `false` too\n         *\n         * See https://www.w3.org/TR/webauthn-2/#dom-authenticatorselectioncriteria-requireresidentkey\n         */\n        authenticatorSelection.requireResidentKey = authenticatorSelection.residentKey === 'required';\n    }\n    /**\n     * Preserve ability to specify `string` values for challenges\n     */\n    let _challenge = challenge;\n    if (typeof _challenge === 'string') {\n        _challenge = isoUint8Array.fromUTF8String(_challenge);\n    }\n    /**\n     * Explicitly disallow use of strings for userID anymore because `isoBase64URL.fromBuffer()` below\n     * will return an empty string if one gets through!\n     */\n    if (typeof userID === 'string') {\n        throw new Error(`String values for \\`userID\\` are no longer supported. See https://simplewebauthn.dev/docs/advanced/server/custom-user-ids`);\n    }\n    /**\n     * Generate a user ID if one is not provided\n     */\n    let _userID = userID;\n    if (!_userID) {\n        _userID = await generateUserID();\n    }\n    /**\n     * Map authenticator preference to hints. Map to authenticatorAttachment as well for\n     * backwards-compatibility.\n     */\n    const hints = [];\n    if (preferredAuthenticatorType) {\n        if (preferredAuthenticatorType === 'securityKey') {\n            hints.push('security-key');\n            authenticatorSelection.authenticatorAttachment = 'cross-platform';\n        }\n        else if (preferredAuthenticatorType === 'localDevice') {\n            hints.push('client-device');\n            authenticatorSelection.authenticatorAttachment = 'platform';\n        }\n        else if (preferredAuthenticatorType === 'remoteDevice') {\n            hints.push('hybrid');\n            authenticatorSelection.authenticatorAttachment = 'cross-platform';\n        }\n    }\n    return {\n        challenge: isoBase64URL.fromBuffer(_challenge),\n        rp: {\n            name: rpName,\n            id: rpID,\n        },\n        user: {\n            id: isoBase64URL.fromBuffer(_userID),\n            name: userName,\n            displayName: userDisplayName,\n        },\n        pubKeyCredParams,\n        timeout,\n        attestation: attestationType,\n        excludeCredentials: excludeCredentials.map((cred) => {\n            if (!isoBase64URL.isBase64URL(cred.id)) {\n                throw new Error(`excludeCredential id \"${cred.id}\" is not a valid base64url string`);\n            }\n            return {\n                ...cred,\n                id: isoBase64URL.trimPadding(cred.id),\n                type: 'public-key',\n            };\n        }),\n        authenticatorSelection,\n        extensions: {\n            ...extensions,\n            credProps: true,\n        },\n        hints,\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2035, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2041, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/parseBackupFlags.js"],"sourcesContent":["/**\n * Make sense of Bits 3 and 4 in authenticator indicating:\n *\n * - Whether the credential can be used on multiple devices\n * - Whether the credential is backed up or not\n *\n * Invalid configurations will raise an `Error`\n */\nexport function parseBackupFlags({ be, bs }) {\n    const credentialBackedUp = bs;\n    let credentialDeviceType = 'singleDevice';\n    if (be) {\n        credentialDeviceType = 'multiDevice';\n    }\n    if (credentialDeviceType === 'singleDevice' && credentialBackedUp) {\n        throw new InvalidBackupFlags('Single-device credential indicated that it was backed up, which should be impossible.');\n    }\n    return { credentialDeviceType, credentialBackedUp };\n}\nexport class InvalidBackupFlags extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InvalidBackupFlags';\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;AACM,SAAS,iBAAiB,EAAE,EAAE,EAAE,EAAE,EAAE;IACvC,MAAM,qBAAqB;IAC3B,IAAI,uBAAuB;IAC3B,IAAI,IAAI;QACJ,uBAAuB;IAC3B;IACA,IAAI,yBAAyB,kBAAkB,oBAAoB;QAC/D,MAAM,IAAI,mBAAmB;IACjC;IACA,OAAO;QAAE;QAAsB;IAAmB;AACtD;AACO,MAAM,2BAA2B;IACpC,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2072, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2078, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/matchExpectedRPID.js"],"sourcesContent":["import { toHash } from './toHash.js';\nimport { isoUint8Array } from './iso/index.js';\n/**\n * Go through each expected RP ID and try to find one that matches. Returns the unhashed RP ID\n * that matched the hash in the response.\n *\n * Raises an `UnexpectedRPIDHash` error if no match is found\n */\nexport async function matchExpectedRPID(rpIDHash, expectedRPIDs) {\n    try {\n        const matchedRPID = await Promise.any(expectedRPIDs.map((expected) => {\n            return new Promise((resolve, reject) => {\n                toHash(isoUint8Array.fromASCIIString(expected)).then((expectedRPIDHash) => {\n                    if (isoUint8Array.areEqual(rpIDHash, expectedRPIDHash)) {\n                        resolve(expected);\n                    }\n                    else {\n                        reject();\n                    }\n                });\n            });\n        }));\n        return matchedRPID;\n    }\n    catch (err) {\n        const _err = err;\n        // This means no matches were found\n        if (_err.name === 'AggregateError') {\n            throw new UnexpectedRPIDHash();\n        }\n        // An unexpected error occurred\n        throw err;\n    }\n}\nclass UnexpectedRPIDHash extends Error {\n    constructor() {\n        const message = 'Unexpected RP ID hash';\n        super(message);\n        this.name = 'UnexpectedRPIDHash';\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AAAA;;;AAOO,eAAe,kBAAkB,QAAQ,EAAE,aAAa;IAC3D,IAAI;QACA,MAAM,cAAc,MAAM,QAAQ,GAAG,CAAC,cAAc,GAAG,CAAC,CAAC;YACrD,OAAO,IAAI,QAAQ,CAAC,SAAS;gBACzB,CAAA,GAAA,gPAAA,CAAA,SAAM,AAAD,EAAE,uSAAA,CAAA,gBAAa,CAAC,eAAe,CAAC,WAAW,IAAI,CAAC,CAAC;oBAClD,IAAI,uSAAA,CAAA,gBAAa,CAAC,QAAQ,CAAC,UAAU,mBAAmB;wBACpD,QAAQ;oBACZ,OACK;wBACD;oBACJ;gBACJ;YACJ;QACJ;QACA,OAAO;IACX,EACA,OAAO,KAAK;QACR,MAAM,OAAO;QACb,mCAAmC;QACnC,IAAI,KAAK,IAAI,KAAK,kBAAkB;YAChC,MAAM,IAAI;QACd;QACA,+BAA+B;QAC/B,MAAM;IACV;AACJ;AACA,MAAM,2BAA2B;IAC7B,aAAc;QACV,MAAM,UAAU;QAChB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;IAChB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2117, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2123, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/services/defaultRootCerts/android-safetynet.js"],"sourcesContent":["/**\n * GlobalSign Root CA\n *\n * Downloaded from https://pki.goog/roots.pem\n *\n * Valid until 2028-01-28 @ 04:00 PST\n *\n * SHA256 Fingerprint\n * EB:D4:10:40:E4:BB:3E:C7:42:C9:E3:81:D3:1E:F2:A4:1A:48:B6:68:5C:96:E7:CE:F3:C1:DF:6C:D4:33:1C:99\n */\nexport const GlobalSign_Root_CA = `-----BEGIN CERTIFICATE-----\nMIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkG\nA1UEBhMCQkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jv\nb3QgQ0ExGzAZBgNVBAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAw\nMDBaFw0yODAxMjgxMjAwMDBaMFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9i\nYWxTaWduIG52LXNhMRAwDgYDVQQLEwdSb290IENBMRswGQYDVQQDExJHbG9iYWxT\naWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDaDuaZ\njc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtIK+6NiY6arymAZavp\nxy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCOXkNz8kHp\n1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG\nsnUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJ\nU26Qzns3dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N8\n9iFo7+ryUp9/k5DPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8E\nBTADAQH/MB0GA1UdDgQWBBRge2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0B\nAQUFAAOCAQEA1nPnfE920I2/7LqivjTFKDK1fPxsnCwrvQmeU79rXqoRSLblCKOz\nyj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY776BQVvnGCv04zcQLcFGUl5gE\n38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9LhJIZJrglfCm7ymP\nAbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr+WymXUad\nDKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME\nHMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==\n-----END CERTIFICATE-----\n`;\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;AACM,MAAM,qBAAqB,CAAC;;;;;;;;;;;;;;;;;;;;;AAqBnC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2163, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/services/defaultRootCerts/android-key.js"],"sourcesContent":["/**\n * Google Hardware Attestation Root 1\n *\n * Downloaded from https://developer.android.com/training/articles/security-key-attestation#root_certificate\n * (first entry)\n *\n * Valid until 2026-05-24 @ 09:28 PST\n *\n * SHA256 Fingerprint\n * C1:98:4A:3E:F4:5C:1E:2A:91:85:51:DE:10:60:3C:86:F7:05:1B:22:49:C4:89:1C:AE:32:30:EA:BD:0C:97:D5\n */\nexport const Google_Hardware_Attestation_Root_1 = `-----BEGIN CERTIFICATE-----\nMIIFYDCCA0igAwIBAgIJAOj6GWMU0voYMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\nBAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTYwNTI2MTYyODUyWhcNMjYwNTI0MTYy\nODUyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B\nAQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS\nSxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7\ntv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj\nnar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq\nC4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ\noVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O\nJtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg\nsTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi\nigHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M\nRPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E\naDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um\nAGMCAwEAAaOBpjCBozAdBgNVHQ4EFgQUNmHhAHyIBQlRi0RsR/8aTMnqTxIwHwYD\nVR0jBBgwFoAUNmHhAHyIBQlRi0RsR/8aTMnqTxIwDwYDVR0TAQH/BAUwAwEB/zAO\nBgNVHQ8BAf8EBAMCAYYwQAYDVR0fBDkwNzA1oDOgMYYvaHR0cHM6Ly9hbmRyb2lk\nLmdvb2dsZWFwaXMuY29tL2F0dGVzdGF0aW9uL2NybC8wDQYJKoZIhvcNAQELBQAD\nggIBACDIw41L3KlXG0aMiS//cqrG+EShHUGo8HNsw30W1kJtjn6UBwRM6jnmiwfB\nPb8VA91chb2vssAtX2zbTvqBJ9+LBPGCdw/E53Rbf86qhxKaiAHOjpvAy5Y3m00m\nqC0w/Zwvju1twb4vhLaJ5NkUJYsUS7rmJKHHBnETLi8GFqiEsqTWpG/6ibYCv7rY\nDBJDcR9W62BW9jfIoBQcxUCUJouMPH25lLNcDc1ssqvC2v7iUgI9LeoM1sNovqPm\nQUiG9rHli1vXxzCyaMTjwftkJLkf6724DFhuKug2jITV0QkXvaJWF4nUaHOTNA4u\nJU9WDvZLI1j83A+/xnAJUucIv/zGJ1AMH2boHqF8CY16LpsYgBt6tKxxWH00XcyD\nCdW2KlBCeqbQPcsFmWyWugxdcekhYsAWyoSf818NUsZdBWBaR/OukXrNLfkQ79Iy\nZohZbvabO/X+MVT3rriAoKc8oE2Uws6DF+60PV7/WIPjNvXySdqspImSN78mflxD\nqwLqRBYkA3I75qppLGG9rp7UCdRjxMl8ZDBld+7yvHVgt1cVzJx9xnyGCC23Uaic\nMDSXYrB4I4WHXPGjxhZuCuPBLTdOLU8YRvMYdEvYebWHMpvwGCF6bAx3JBpIeOQ1\nwDB5y0USicV3YgYGmi+NZfhA4URSh77Yd6uuJOJENRaNVTzk\n-----END CERTIFICATE-----\n`;\n/**\n * Google Hardware Attestation Root 2\n *\n * Downloaded from https://developer.android.com/training/articles/security-key-attestation#root_certificate\n * (second entry)\n *\n * Valid until 2034-11-18 @ 12:37 PST\n *\n * SHA256 Fingerprint\n * 1E:F1:A0:4B:8B:A5:8A:B9:45:89:AC:49:8C:89:82:A7:83:F2:4E:A7:30:7E:01:59:A0:C3:A7:3B:37:7D:87:CC\n */\nexport const Google_Hardware_Attestation_Root_2 = `-----BEGIN CERTIFICATE-----\nMIIFHDCCAwSgAwIBAgIJANUP8luj8tazMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\nBAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMTkxMTIyMjAzNzU4WhcNMzQxMTE4MjAz\nNzU4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B\nAQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS\nSxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7\ntv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj\nnar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq\nC4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ\noVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O\nJtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg\nsTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi\nigHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M\nRPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E\naDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um\nAGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud\nIwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD\nVR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBOMaBc8oumXb2voc7XCWnu\nXKhBBK3e2KMGz39t7lA3XXRe2ZLLAkLM5y3J7tURkf5a1SutfdOyXAmeE6SRo83U\nh6WszodmMkxK5GM4JGrnt4pBisu5igXEydaW7qq2CdC6DOGjG+mEkN8/TA6p3cno\nL/sPyz6evdjLlSeJ8rFBH6xWyIZCbrcpYEJzXaUOEaxxXxgYz5/cTiVKN2M1G2ok\nQBUIYSY6bjEL4aUN5cfo7ogP3UvliEo3Eo0YgwuzR2v0KR6C1cZqZJSTnghIC/vA\nD32KdNQ+c3N+vl2OTsUVMC1GiWkngNx1OO1+kXW+YTnnTUOtOIswUP/Vqd5SYgAI\nmMAfY8U9/iIgkQj6T2W6FsScy94IN9fFhE1UtzmLoBIuUFsVXJMTz+Jucth+IqoW\nFua9v1R93/k98p41pjtFX+H8DslVgfP097vju4KDlqN64xV1grw3ZLl4CiOe/A91\noeLm2UHOq6wn3esB4r2EIQKb6jTVGu5sYCcdWpXr0AUVqcABPdgL+H7qJguBw09o\njm6xNIrw2OocrDKsudk/okr/AwqEyPKw9WnMlQgLIKw1rODG2NvU9oR3GVGdMkUB\nZutL8VuFkERQGt6vQ2OCw0sV47VMkuYbacK/xyZFiRcrPJPb41zgbQj9XAEyLKCH\nex0SdDrx+tWUDqG8At2JHA==\n-----END CERTIFICATE-----\n`;\n/**\n * Google Hardware Attestation Root 3\n *\n * Downloaded from https://developer.android.com/training/articles/security-key-attestation#root_certificate\n * (third entry)\n *\n * Valid until 2036-11-13 @ 15:10 PST\n *\n * SHA256 Fingerprint\n * AB:66:41:17:8A:36:E1:79:AA:0C:1C:DD:DF:9A:16:EB:45:FA:20:94:3E:2B:8C:D7:C7:C0:5C:26:CF:8B:48:7A\n */\nexport const Google_Hardware_Attestation_Root_3 = `\n-----BEGIN CERTIFICATE-----\nMIIFHDCCAwSgAwIBAgIJAMNrfES5rhgxMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\nBAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMjExMTE3MjMxMDQyWhcNMzYxMTEzMjMx\nMDQyWjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B\nAQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS\nSxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7\ntv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj\nnar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq\nC4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ\noVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O\nJtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg\nsTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi\nigHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M\nRPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E\naDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um\nAGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud\nIwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD\nVR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQBTNNZe5cuf8oiq+jV0itTG\nzWVhSTjOBEk2FQvh11J3o3lna0o7rd8RFHnN00q4hi6TapFhh4qaw/iG6Xg+xOan\n63niLWIC5GOPFgPeYXM9+nBb3zZzC8ABypYuCusWCmt6Tn3+Pjbz3MTVhRGXuT/T\nQH4KGFY4PhvzAyXwdjTOCXID+aHud4RLcSySr0Fq/L+R8TWalvM1wJJPhyRjqRCJ\nerGtfBagiALzvhnmY7U1qFcS0NCnKjoO7oFedKdWlZz0YAfu3aGCJd4KHT0MsGiL\nZez9WP81xYSrKMNEsDK+zK5fVzw6jA7cxmpXcARTnmAuGUeI7VVDhDzKeVOctf3a\n0qQLwC+d0+xrETZ4r2fRGNw2YEs2W8Qj6oDcfPvq9JySe7pJ6wcHnl5EZ0lwc4xH\n7Y4Dx9RA1JlfooLMw3tOdJZH0enxPXaydfAD3YifeZpFaUzicHeLzVJLt9dvGB0b\nHQLE4+EqKFgOZv2EoP686DQqbVS1u+9k0p2xbMA105TBIk7npraa8VM0fnrRKi7w\nlZKwdH+aNAyhbXRW9xsnODJ+g8eF452zvbiKKngEKirK5LGieoXBX7tZ9D1GNBH2\nOb3bKOwwIWdEFle/YF/h6zWgdeoaNGDqVBrLr2+0DtWoiB1aDEjLWl9FmyIUyUm7\nmD/vFDkzF+wm7cyWpQpCVQ==\n-----END CERTIFICATE-----\n`;\n/**\n * Google Hardware Attestation Root 4\n *\n * Downloaded from https://developer.android.com/training/articles/security-key-attestation#root_certificate\n * (fourth entry)\n *\n * Valid until 2042-03-15 @ 11:07 PDT\n *\n * SHA256 Fingerprint\n * CE:DB:1C:B6:DC:89:6A:E5:EC:79:73:48:BC:E9:28:67:53:C2:B3:8E:E7:1C:E0:FB:E3:4A:9A:12:48:80:0D:FC\n */\nexport const Google_Hardware_Attestation_Root_4 = `\n-----BEGIN CERTIFICATE-----\nMIIFHDCCAwSgAwIBAgIJAPHBcqaZ6vUdMA0GCSqGSIb3DQEBCwUAMBsxGTAXBgNV\nBAUTEGY5MjAwOWU4NTNiNmIwNDUwHhcNMjIwMzIwMTgwNzQ4WhcNNDIwMzE1MTgw\nNzQ4WjAbMRkwFwYDVQQFExBmOTIwMDllODUzYjZiMDQ1MIICIjANBgkqhkiG9w0B\nAQEFAAOCAg8AMIICCgKCAgEAr7bHgiuxpwHsK7Qui8xUFmOr75gvMsd/dTEDDJdS\nSxtf6An7xyqpRR90PL2abxM1dEqlXnf2tqw1Ne4Xwl5jlRfdnJLmN0pTy/4lj4/7\ntv0Sk3iiKkypnEUtR6WfMgH0QZfKHM1+di+y9TFRtv6y//0rb+T+W8a9nsNL/ggj\nnar86461qO0rOs2cXjp3kOG1FEJ5MVmFmBGtnrKpa73XpXyTqRxB/M0n1n/W9nGq\nC4FSYa04T6N5RIZGBN2z2MT5IKGbFlbC8UrW0DxW7AYImQQcHtGl/m00QLVWutHQ\noVJYnFPlXTcHYvASLu+RhhsbDmxMgJJ0mcDpvsC4PjvB+TxywElgS70vE0XmLD+O\nJtvsBslHZvPBKCOdT0MS+tgSOIfga+z1Z1g7+DVagf7quvmag8jfPioyKvxnK/Eg\nsTUVi2ghzq8wm27ud/mIM7AY2qEORR8Go3TVB4HzWQgpZrt3i5MIlCaY504LzSRi\nigHCzAPlHws+W0rB5N+er5/2pJKnfBSDiCiFAVtCLOZ7gLiMm0jhO2B6tUXHI/+M\nRPjy02i59lINMRRev56GKtcd9qO/0kUJWdZTdA2XoS82ixPvZtXQpUpuL12ab+9E\naDK8Z4RHJYYfCT3Q5vNAXaiWQ+8PTWm2QgBR/bkwSWc+NpUFgNPN9PvQi8WEg5Um\nAGMCAwEAAaNjMGEwHQYDVR0OBBYEFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMB8GA1Ud\nIwQYMBaAFDZh4QB8iAUJUYtEbEf/GkzJ6k8SMA8GA1UdEwEB/wQFMAMBAf8wDgYD\nVR0PAQH/BAQDAgIEMA0GCSqGSIb3DQEBCwUAA4ICAQB8cMqTllHc8U+qCrOlg3H7\n174lmaCsbo/bJ0C17JEgMLb4kvrqsXZs01U3mB/qABg/1t5Pd5AORHARs1hhqGIC\nW/nKMav574f9rZN4PC2ZlufGXb7sIdJpGiO9ctRhiLuYuly10JccUZGEHpHSYM2G\ntkgYbZba6lsCPYAAP83cyDV+1aOkTf1RCp/lM0PKvmxYN10RYsK631jrleGdcdkx\noSK//mSQbgcWnmAEZrzHoF1/0gso1HZgIn0YLzVhLSA/iXCX4QT2h3J5z3znluKG\n1nv8NQdxei2DIIhASWfu804CA96cQKTTlaae2fweqXjdN1/v2nqOhngNyz1361mF\nmr4XmaKH/ItTwOe72NI9ZcwS1lVaCvsIkTDCEXdm9rCNPAY10iTunIHFXRh+7KPz\nlHGewCq/8TOohBRn0/NNfh7uRslOSZ/xKbN9tMBtw37Z8d2vvnXq/YWdsm1+JLVw\nn6yYD/yacNJBlwpddla8eaVMjsF6nBnIgQOf9zKSe06nSTqvgwUHosgOECZJZ1Eu\nzbH4yswbt02tKtKEFhx+v+OTge/06V+jGsqTWLsfrOCNLuA8H++z+pUENmpqnnHo\nvaI47gC+TNpkgYGkkBT6B/m/U01BuOBBTzhIlMEZq9qkDWuM2cA5kW5V3FJUcfHn\nw1IdYIg2Wxg7yHcQZemFQg==\n-----END CERTIFICATE-----\n`;\n"],"names":[],"mappings":"AAAA;;;;;;;;;;CAUC;;;;;;AACM,MAAM,qCAAqC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BnD,CAAC;AAYM,MAAM,qCAAqC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BnD,CAAC;AAYM,MAAM,qCAAqC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BnD,CAAC;AAYM,MAAM,qCAAqC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BnD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2306, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2312, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/services/defaultRootCerts/apple.js"],"sourcesContent":["/**\n * Apple WebAuthn Root CA\n *\n * Downloaded from https://www.apple.com/certificateauthority/Apple_WebAuthn_Root_CA.pem\n *\n * Valid until 2045-03-14 @ 17:00 PST\n *\n * SHA256 Fingerprint\n * 09:15:DD:5C:07:A2:8D:B5:49:D1:F6:77:BB:5A:75:D4:BF:BE:95:61:A7:73:42:43:27:76:2E:9E:02:F9:BB:29\n */\nexport const Apple_WebAuthn_Root_CA = `-----BEGIN CERTIFICATE-----\nMIICEjCCAZmgAwIBAgIQaB0BbHo84wIlpQGUKEdXcTAKBggqhkjOPQQDAzBLMR8w\nHQYDVQQDDBZBcHBsZSBXZWJBdXRobiBSb290IENBMRMwEQYDVQQKDApBcHBsZSBJ\nbmMuMRMwEQYDVQQIDApDYWxpZm9ybmlhMB4XDTIwMDMxODE4MjEzMloXDTQ1MDMx\nNTAwMDAwMFowSzEfMB0GA1UEAwwWQXBwbGUgV2ViQXV0aG4gUm9vdCBDQTETMBEG\nA1UECgwKQXBwbGUgSW5jLjETMBEGA1UECAwKQ2FsaWZvcm5pYTB2MBAGByqGSM49\nAgEGBSuBBAAiA2IABCJCQ2pTVhzjl4Wo6IhHtMSAzO2cv+H9DQKev3//fG59G11k\nxu9eI0/7o6V5uShBpe1u6l6mS19S1FEh6yGljnZAJ+2GNP1mi/YK2kSXIuTHjxA/\npcoRf7XkOtO4o1qlcaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUJtdk\n2cV4wlpn0afeaxLQG2PxxtcwDgYDVR0PAQH/BAQDAgEGMAoGCCqGSM49BAMDA2cA\nMGQCMFrZ+9DsJ1PW9hfNdBywZDsWDbWFp28it1d/5w2RPkRX3Bbn/UbDTNLx7Jr3\njAGGiQIwHFj+dJZYUJR786osByBelJYsVZd2GbHQu209b5RCmGQ21gpSAk9QZW4B\n1bWeT0vT\n-----END CERTIFICATE-----\n`;\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;AACM,MAAM,yBAAyB,CAAC;;;;;;;;;;;;;;AAcvC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2339, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2345, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/services/defaultRootCerts/mds.js"],"sourcesContent":["/**\n * GlobalSign Root CA - R3\n *\n * Downloaded from https://valid.r3.roots.globalsign.com/\n *\n * Valid until 2029-03-18 @ 00:00 PST\n *\n * SHA256 Fingerprint\n * CB:B5:22:D7:B7:F1:27:AD:6A:01:13:86:5B:DF:1C:D4:10:2E:7D:07:59:AF:63:5A:7C:F4:72:0D:C9:63:C5:3B\n */\nexport const GlobalSign_Root_CA_R3 = `-----BEGIN CERTIFICATE-----\n MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\n A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\n Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\n MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\n A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\n hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\n RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\n gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\n KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\n QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\n XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\n DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\n LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\n RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\n jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n 6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\n mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\n Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\n WD9f\n -----END CERTIFICATE-----\n `;\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;AACM,MAAM,wBAAwB,CAAC;;;;;;;;;;;;;;;;;;;;;CAqBrC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2385, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/services/settingsService.js"],"sourcesContent":["import { convertCertBufferToPEM } from '../helpers/convertCertBufferToPEM.js';\nimport { GlobalSign_Root_CA } from './defaultRootCerts/android-safetynet.js';\nimport { Google_Hardware_Attestation_Root_1, Google_Hardware_Attestation_Root_2, Google_Hardware_Attestation_Root_3, Google_Hardware_Attestation_Root_4, } from './defaultRootCerts/android-key.js';\nimport { Apple_WebAuthn_Root_CA } from './defaultRootCerts/apple.js';\nimport { GlobalSign_Root_CA_R3 } from './defaultRootCerts/mds.js';\nclass BaseSettingsService {\n    constructor() {\n        // Certificates are stored as PEM-formatted strings\n        Object.defineProperty(this, \"pemCertificates\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pemCertificates = new Map();\n    }\n    setRootCertificates(opts) {\n        const { identifier, certificates } = opts;\n        const newCertificates = [];\n        for (const cert of certificates) {\n            if (cert instanceof Uint8Array) {\n                newCertificates.push(convertCertBufferToPEM(cert));\n            }\n            else {\n                newCertificates.push(cert);\n            }\n        }\n        this.pemCertificates.set(identifier, newCertificates);\n    }\n    getRootCertificates(opts) {\n        const { identifier } = opts;\n        return this.pemCertificates.get(identifier) ?? [];\n    }\n}\n/**\n * A basic service for specifying acceptable root certificates for all supported attestation\n * statement formats.\n *\n * In addition, default root certificates are included for the following statement formats:\n *\n * - `'android-key'`\n * - `'android-safetynet'`\n * - `'apple'`\n * - `'android-mds'`\n *\n * These can be overwritten as needed by setting alternative root certificates for their format\n * identifier using `setRootCertificates()`.\n */\nexport const SettingsService = new BaseSettingsService();\n// Initialize default certificates\nSettingsService.setRootCertificates({\n    identifier: 'android-key',\n    certificates: [\n        Google_Hardware_Attestation_Root_1,\n        Google_Hardware_Attestation_Root_2,\n        Google_Hardware_Attestation_Root_3,\n        Google_Hardware_Attestation_Root_4,\n    ],\n});\nSettingsService.setRootCertificates({\n    identifier: 'android-safetynet',\n    certificates: [GlobalSign_Root_CA],\n});\nSettingsService.setRootCertificates({\n    identifier: 'apple',\n    certificates: [Apple_WebAuthn_Root_CA],\n});\nSettingsService.setRootCertificates({\n    identifier: 'mds',\n    certificates: [GlobalSign_Root_CA_R3],\n});\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA,MAAM;IACF,aAAc;QACV,mDAAmD;QACnD,OAAO,cAAc,CAAC,IAAI,EAAE,mBAAmB;YAC3C,YAAY;YACZ,cAAc;YACd,UAAU;YACV,OAAO,KAAK;QAChB;QACA,IAAI,CAAC,eAAe,GAAG,IAAI;IAC/B;IACA,oBAAoB,IAAI,EAAE;QACtB,MAAM,EAAE,UAAU,EAAE,YAAY,EAAE,GAAG;QACrC,MAAM,kBAAkB,EAAE;QAC1B,KAAK,MAAM,QAAQ,aAAc;YAC7B,IAAI,gBAAgB,YAAY;gBAC5B,gBAAgB,IAAI,CAAC,CAAA,GAAA,gQAAA,CAAA,yBAAsB,AAAD,EAAE;YAChD,OACK;gBACD,gBAAgB,IAAI,CAAC;YACzB;QACJ;QACA,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,YAAY;IACzC;IACA,oBAAoB,IAAI,EAAE;QACtB,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,eAAe,EAAE;IACrD;AACJ;AAeO,MAAM,kBAAkB,IAAI;AACnC,kCAAkC;AAClC,gBAAgB,mBAAmB,CAAC;IAChC,YAAY;IACZ,cAAc;QACV,6QAAA,CAAA,qCAAkC;QAClC,6QAAA,CAAA,qCAAkC;QAClC,6QAAA,CAAA,qCAAkC;QAClC,6QAAA,CAAA,qCAAkC;KACrC;AACL;AACA,gBAAgB,mBAAmB,CAAC;IAChC,YAAY;IACZ,cAAc;QAAC,mRAAA,CAAA,qBAAkB;KAAC;AACtC;AACA,gBAAgB,mBAAmB,CAAC;IAChC,YAAY;IACZ,cAAc;QAAC,oQAAA,CAAA,yBAAsB;KAAC;AAC1C;AACA,gBAAgB,mBAAmB,CAAC;IAChC,YAAY;IACZ,cAAc;QAAC,kQAAA,CAAA,wBAAqB;KAAC;AACzC","ignoreList":[0]}},
    {"offset": {"line": 2455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2461, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/verifyAttestationFIDOU2F.js"],"sourcesContent":["import { convertCOSEtoPKCS } from '../../helpers/convertCOSEtoPKCS.js';\nimport { convertCertBufferToPEM } from '../../helpers/convertCertBufferToPEM.js';\nimport { validateCertificatePath } from '../../helpers/validateCertificatePath.js';\nimport { verifySignature } from '../../helpers/verifySignature.js';\nimport { isoUint8Array } from '../../helpers/iso/index.js';\nimport { COSEALG } from '../../helpers/cose.js';\n/**\n * Verify an attestation response with fmt 'fido-u2f'\n */\nexport async function verifyAttestationFIDOU2F(options) {\n    const { attStmt, clientDataHash, rpIdHash, credentialID, credentialPublicKey, aaguid, rootCertificates, } = options;\n    const reservedByte = Uint8Array.from([0x00]);\n    const publicKey = convertCOSEtoPKCS(credentialPublicKey);\n    const signatureBase = isoUint8Array.concat([\n        reservedByte,\n        rpIdHash,\n        clientDataHash,\n        credentialID,\n        publicKey,\n    ]);\n    const sig = attStmt.get('sig');\n    const x5c = attStmt.get('x5c');\n    if (!x5c) {\n        throw new Error('No attestation certificate provided in attestation statement (FIDOU2F)');\n    }\n    if (!sig) {\n        throw new Error('No attestation signature provided in attestation statement (FIDOU2F)');\n    }\n    // FIDO spec says that aaguid _must_ equal 0x00 here to be legit\n    const aaguidToHex = Number.parseInt(isoUint8Array.toHex(aaguid), 16);\n    if (aaguidToHex !== 0x00) {\n        throw new Error(`AAGUID \"${aaguidToHex}\" was not expected value`);\n    }\n    try {\n        // Try validating the certificate path using the root certificates set via SettingsService\n        await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);\n    }\n    catch (err) {\n        const _err = err;\n        throw new Error(`${_err.message} (FIDOU2F)`);\n    }\n    return verifySignature({\n        signature: sig,\n        data: signatureBase,\n        x509Certificate: x5c[0],\n        hashAlgorithm: COSEALG.ES256,\n    });\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AADA;;;;;;;AAKO,eAAe,yBAAyB,OAAO;IAClD,MAAM,EAAE,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,YAAY,EAAE,mBAAmB,EAAE,MAAM,EAAE,gBAAgB,EAAG,GAAG;IAC5G,MAAM,eAAe,WAAW,IAAI,CAAC;QAAC;KAAK;IAC3C,MAAM,YAAY,CAAA,GAAA,2PAAA,CAAA,oBAAiB,AAAD,EAAE;IACpC,MAAM,gBAAgB,uSAAA,CAAA,gBAAa,CAAC,MAAM,CAAC;QACvC;QACA;QACA;QACA;QACA;KACH;IACD,MAAM,MAAM,QAAQ,GAAG,CAAC;IACxB,MAAM,MAAM,QAAQ,GAAG,CAAC;IACxB,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA,gEAAgE;IAChE,MAAM,cAAc,OAAO,QAAQ,CAAC,uSAAA,CAAA,gBAAa,CAAC,KAAK,CAAC,SAAS;IACjE,IAAI,gBAAgB,MAAM;QACtB,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,YAAY,wBAAwB,CAAC;IACpE;IACA,IAAI;QACA,0FAA0F;QAC1F,MAAM,CAAA,GAAA,iQAAA,CAAA,0BAAuB,AAAD,EAAE,IAAI,GAAG,CAAC,gQAAA,CAAA,yBAAsB,GAAG;IACnE,EACA,OAAO,KAAK;QACR,MAAM,OAAO;QACb,MAAM,IAAI,MAAM,GAAG,KAAK,OAAO,CAAC,UAAU,CAAC;IAC/C;IACA,OAAO,CAAA,GAAA,yPAAA,CAAA,kBAAe,AAAD,EAAE;QACnB,WAAW;QACX,MAAM;QACN,iBAAiB,GAAG,CAAC,EAAE;QACvB,eAAe,8OAAA,CAAA,UAAO,CAAC,KAAK;IAChC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2517, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2523, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/validateExtFIDOGenCEAAGUID.js"],"sourcesContent":["import { AsnParser, OctetString } from '@peculiar/asn1-schema';\nimport { isoUint8Array } from './iso/index.js';\n/**\n * Attestation Certificate Extension OID: `id-fido-gen-ce-aaguid`\n *\n * Sourced from https://fidoalliance.org/specs/fido-v2.0-ps-20150904/fido-key-attestation-v2.0-ps-20150904.html#verifying-an-attestation-statement\n */\nconst id_fido_gen_ce_aaguid = '1.3.6.1.4.1.45724.1.1.4';\n/**\n * Look for the id-fido-gen-ce-aaguid certificate extension. If it's present then check it against\n * the attestation statement AAGUID.\n */\nexport function validateExtFIDOGenCEAAGUID(certExtensions, aaguid) {\n    // The certificate had no extensions so there's nothing to validate\n    if (!certExtensions) {\n        return true;\n    }\n    const extFIDOGenCEAAGUID = certExtensions.find((ext) => ext.extnID === id_fido_gen_ce_aaguid);\n    // The extension isn't present so there's nothing to validate\n    if (!extFIDOGenCEAAGUID) {\n        return true;\n    }\n    // Parse the extension value\n    const parsedExtFIDOGenCEAAGUID = AsnParser.parse(extFIDOGenCEAAGUID.extnValue, OctetString);\n    const extValue = new Uint8Array(parsedExtFIDOGenCEAAGUID.buffer);\n    // Compare the two values\n    const aaguidAndExtAreEqual = isoUint8Array.areEqual(aaguid, extValue);\n    if (!aaguidAndExtAreEqual) {\n        const _debugExtHex = isoUint8Array.toHex(extValue);\n        const _debugAAGUIDHex = isoUint8Array.toHex(aaguid);\n        throw new Error(`Certificate extension id-fido-gen-ce-aaguid (${id_fido_gen_ce_aaguid}) value of \"${_debugExtHex}\" was present but not equal to attestation statement AAGUID value of \"${_debugAAGUIDHex}\"`);\n    }\n    return true;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AADA;AAAA;AACA;;;AACA;;;;CAIC,GACD,MAAM,wBAAwB;AAKvB,SAAS,2BAA2B,cAAc,EAAE,MAAM;IAC7D,mEAAmE;IACnE,IAAI,CAAC,gBAAgB;QACjB,OAAO;IACX;IACA,MAAM,qBAAqB,eAAe,IAAI,CAAC,CAAC,MAAQ,IAAI,MAAM,KAAK;IACvE,6DAA6D;IAC7D,IAAI,CAAC,oBAAoB;QACrB,OAAO;IACX;IACA,4BAA4B;IAC5B,MAAM,2BAA2B,qPAAA,CAAA,YAAS,CAAC,KAAK,CAAC,mBAAmB,SAAS,EAAE,oQAAA,CAAA,cAAW;IAC1F,MAAM,WAAW,IAAI,WAAW,yBAAyB,MAAM;IAC/D,yBAAyB;IACzB,MAAM,uBAAuB,uSAAA,CAAA,gBAAa,CAAC,QAAQ,CAAC,QAAQ;IAC5D,IAAI,CAAC,sBAAsB;QACvB,MAAM,eAAe,uSAAA,CAAA,gBAAa,CAAC,KAAK,CAAC;QACzC,MAAM,kBAAkB,uSAAA,CAAA,gBAAa,CAAC,KAAK,CAAC;QAC5C,MAAM,IAAI,MAAM,CAAC,6CAA6C,EAAE,sBAAsB,YAAY,EAAE,aAAa,sEAAsE,EAAE,gBAAgB,CAAC,CAAC;IAC/M;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 2560, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2566, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/helpers/logging.js"],"sourcesContent":["// const defaultLogger = debug('SimpleWebAuthn');\n/**\n * Generate an instance of a `debug` logger that extends off of the \"simplewebauthn\" namespace for\n * consistent naming.\n *\n * See https://www.npmjs.com/package/debug for information on how to control logging output when\n * using @simplewebauthn/server\n *\n * Example:\n *\n * ```\n * const log = getLogger('mds');\n * log('hello'); // simplewebauthn:mds hello +0ms\n * ```\n */\nexport function getLogger(_name) {\n    // This is a noop for now while I search for a better debug logger technique\n    return (_message, ..._rest) => { };\n}\n"],"names":[],"mappings":"AAAA,iDAAiD;AACjD;;;;;;;;;;;;;CAaC;;;AACM,SAAS,UAAU,KAAK;IAC3B,4EAA4E;IAC5E,OAAO,CAAC,UAAU,GAAG,SAAY;AACrC","ignoreList":[0]}},
    {"offset": {"line": 2587, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2593, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/metadata/parseJWT.js"],"sourcesContent":["import { isoBase64URL } from '../helpers/iso/index.js';\n/**\n * Process a JWT into Javascript-friendly data structures\n */\nexport function parseJWT(jwt) {\n    const parts = jwt.split('.');\n    return [\n        JSON.parse(isoBase64URL.toUTF8String(parts[0])),\n        JSON.parse(isoBase64URL.toUTF8String(parts[1])),\n        parts[2],\n    ];\n}\n"],"names":[],"mappings":";;;AAAA;AAAA;;AAIO,SAAS,SAAS,GAAG;IACxB,MAAM,QAAQ,IAAI,KAAK,CAAC;IACxB,OAAO;QACH,KAAK,KAAK,CAAC,qSAAA,CAAA,eAAY,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;QAC7C,KAAK,KAAK,CAAC,qSAAA,CAAA,eAAY,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;QAC7C,KAAK,CAAC,EAAE;KACX;AACL","ignoreList":[0]}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2613, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/metadata/verifyJWT.js"],"sourcesContent":["import { convertX509PublicKeyToCOSE } from '../helpers/convertX509PublicKeyToCOSE.js';\nimport { isoBase64URL, isoUint8Array } from '../helpers/iso/index.js';\nimport { COSEALG, COSEKEYS, isCOSEPublicKeyEC2, isCOSEPublicKeyRSA } from '../helpers/cose.js';\nimport { verifyEC2 } from '../helpers/iso/isoCrypto/verifyEC2.js';\nimport { verifyRSA } from '../helpers/iso/isoCrypto/verifyRSA.js';\n/**\n * Lightweight verification for FIDO MDS JWTs. Supports use of EC2 and RSA.\n *\n * If this ever needs to support more JWS algorithms, here's the list of them:\n *\n * https://www.rfc-editor.org/rfc/rfc7518.html#section-3.1\n *\n * (Pulled from https://www.rfc-editor.org/rfc/rfc7515#section-4.1.1)\n */\nexport function verifyJWT(jwt, leafCert) {\n    const [header, payload, signature] = jwt.split('.');\n    const certCOSE = convertX509PublicKeyToCOSE(leafCert);\n    const data = isoUint8Array.fromUTF8String(`${header}.${payload}`);\n    const signatureBytes = isoBase64URL.toBuffer(signature);\n    if (isCOSEPublicKeyEC2(certCOSE)) {\n        return verifyEC2({\n            data,\n            signature: signatureBytes,\n            cosePublicKey: certCOSE,\n            shaHashOverride: COSEALG.ES256,\n        });\n    }\n    else if (isCOSEPublicKeyRSA(certCOSE)) {\n        return verifyRSA({\n            data,\n            signature: signatureBytes,\n            cosePublicKey: certCOSE,\n        });\n    }\n    const kty = certCOSE.get(COSEKEYS.kty);\n    throw new Error(`JWT verification with public key of kty ${kty} is not supported by this method`);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AAHA;AAAA;;;;;;AAaO,SAAS,UAAU,GAAG,EAAE,QAAQ;IACnC,MAAM,CAAC,QAAQ,SAAS,UAAU,GAAG,IAAI,KAAK,CAAC;IAC/C,MAAM,WAAW,CAAA,GAAA,oQAAA,CAAA,6BAA0B,AAAD,EAAE;IAC5C,MAAM,OAAO,uSAAA,CAAA,gBAAa,CAAC,cAAc,CAAC,GAAG,OAAO,CAAC,EAAE,SAAS;IAChE,MAAM,iBAAiB,qSAAA,CAAA,eAAY,CAAC,QAAQ,CAAC;IAC7C,IAAI,CAAA,GAAA,8OAAA,CAAA,qBAAkB,AAAD,EAAE,WAAW;QAC9B,OAAO,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;YACb;YACA,WAAW;YACX,eAAe;YACf,iBAAiB,8OAAA,CAAA,UAAO,CAAC,KAAK;QAClC;IACJ,OACK,IAAI,CAAA,GAAA,8OAAA,CAAA,qBAAkB,AAAD,EAAE,WAAW;QACnC,OAAO,CAAA,GAAA,uQAAA,CAAA,YAAS,AAAD,EAAE;YACb;YACA,WAAW;YACX,eAAe;QACnB;IACJ;IACA,MAAM,MAAM,SAAS,GAAG,CAAC,8OAAA,CAAA,WAAQ,CAAC,GAAG;IACrC,MAAM,IAAI,MAAM,CAAC,wCAAwC,EAAE,IAAI,gCAAgC,CAAC;AACpG","ignoreList":[0]}},
    {"offset": {"line": 2650, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2656, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/services/metadataService.js"],"sourcesContent":["import { validateCertificatePath } from '../helpers/validateCertificatePath.js';\nimport { convertCertBufferToPEM } from '../helpers/convertCertBufferToPEM.js';\nimport { convertAAGUIDToString } from '../helpers/convertAAGUIDToString.js';\nimport { SettingsService } from './settingsService.js';\nimport { getLogger } from '../helpers/logging.js';\nimport { convertPEMToBytes } from '../helpers/convertPEMToBytes.js';\nimport { fetch } from '../helpers/fetch.js';\nimport { parseJWT } from '../metadata/parseJWT.js';\nimport { verifyJWT } from '../metadata/verifyJWT.js';\nconst defaultURLMDS = 'https://mds.fidoalliance.org/'; // v3\nvar SERVICE_STATE;\n(function (SERVICE_STATE) {\n    SERVICE_STATE[SERVICE_STATE[\"DISABLED\"] = 0] = \"DISABLED\";\n    SERVICE_STATE[SERVICE_STATE[\"REFRESHING\"] = 1] = \"REFRESHING\";\n    SERVICE_STATE[SERVICE_STATE[\"READY\"] = 2] = \"READY\";\n})(SERVICE_STATE || (SERVICE_STATE = {}));\nconst log = getLogger('MetadataService');\n/**\n * An implementation of `MetadataService` that can download and parse BLOBs, and support on-demand\n * requesting and caching of individual metadata statements.\n *\n * https://fidoalliance.org/metadata/\n */\nexport class BaseMetadataService {\n    constructor() {\n        Object.defineProperty(this, \"mdsCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"statementCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: SERVICE_STATE.DISABLED\n        });\n        Object.defineProperty(this, \"verificationMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'strict'\n        });\n    }\n    async initialize(opts = {}) {\n        const { mdsServers = [defaultURLMDS], statements, verificationMode } = opts;\n        this.setState(SERVICE_STATE.REFRESHING);\n        // If metadata statements are provided, load them into the cache first\n        if (statements?.length) {\n            let statementsAdded = 0;\n            statements.forEach((statement) => {\n                // Only cache statements that are for FIDO2-compatible authenticators\n                if (statement.aaguid) {\n                    this.statementCache[statement.aaguid] = {\n                        entry: {\n                            metadataStatement: statement,\n                            statusReports: [],\n                            timeOfLastStatusChange: '1970-01-01',\n                        },\n                        url: '',\n                    };\n                    statementsAdded += 1;\n                }\n            });\n            log(`Cached ${statementsAdded} local statements`);\n        }\n        // If MDS servers are provided, then process them and add their statements to the cache\n        if (mdsServers?.length) {\n            // Get a current count so we know how many new statements we've added from MDS servers\n            const currentCacheCount = Object.keys(this.statementCache).length;\n            let numServers = mdsServers.length;\n            for (const url of mdsServers) {\n                try {\n                    await this.downloadBlob({\n                        url,\n                        no: 0,\n                        nextUpdate: new Date(0),\n                    });\n                }\n                catch (err) {\n                    // Notify of the error and move on\n                    log(`Could not download BLOB from ${url}:`, err);\n                    numServers -= 1;\n                }\n            }\n            // Calculate the difference to get the total number of new statements we successfully added\n            const newCacheCount = Object.keys(this.statementCache).length;\n            const cacheDiff = newCacheCount - currentCacheCount;\n            log(`Cached ${cacheDiff} statements from ${numServers} metadata server(s)`);\n        }\n        if (verificationMode) {\n            this.verificationMode = verificationMode;\n        }\n        this.setState(SERVICE_STATE.READY);\n    }\n    async getStatement(aaguid) {\n        if (this.state === SERVICE_STATE.DISABLED) {\n            return;\n        }\n        if (!aaguid) {\n            return;\n        }\n        if (aaguid instanceof Uint8Array) {\n            aaguid = convertAAGUIDToString(aaguid);\n        }\n        // If a cache refresh is in progress then pause this until the service is ready\n        await this.pauseUntilReady();\n        // Try to grab a cached statement\n        const cachedStatement = this.statementCache[aaguid];\n        if (!cachedStatement) {\n            if (this.verificationMode === 'strict') {\n                // FIDO conformance requires RP's to only support registered AAGUID's\n                throw new Error(`No metadata statement found for aaguid \"${aaguid}\"`);\n            }\n            // Allow registration verification to continue without using metadata\n            return;\n        }\n        // If the statement points to an MDS API, check the MDS' nextUpdate to see if we need to refresh\n        if (cachedStatement.url) {\n            const mds = this.mdsCache[cachedStatement.url];\n            const now = new Date();\n            if (now > mds.nextUpdate) {\n                try {\n                    this.setState(SERVICE_STATE.REFRESHING);\n                    await this.downloadBlob(mds);\n                }\n                finally {\n                    this.setState(SERVICE_STATE.READY);\n                }\n            }\n        }\n        const { entry } = cachedStatement;\n        // Check to see if the this aaguid has a status report with a \"compromised\" status\n        for (const report of entry.statusReports) {\n            const { status } = report;\n            if (status === 'USER_VERIFICATION_BYPASS' ||\n                status === 'ATTESTATION_KEY_COMPROMISE' ||\n                status === 'USER_KEY_REMOTE_COMPROMISE' ||\n                status === 'USER_KEY_PHYSICAL_COMPROMISE') {\n                throw new Error(`Detected compromised aaguid \"${aaguid}\"`);\n            }\n        }\n        return entry.metadataStatement;\n    }\n    /**\n     * Download and process the latest BLOB from MDS\n     */\n    async downloadBlob(mds) {\n        const { url, no } = mds;\n        // Get latest \"BLOB\" (FIDO's terminology, not mine)\n        const resp = await fetch(url);\n        const data = await resp.text();\n        // Parse the JWT\n        const parsedJWT = parseJWT(data);\n        const header = parsedJWT[0];\n        const payload = parsedJWT[1];\n        if (payload.no <= no) {\n            // From FIDO MDS docs: \"also ignore the file if its number (no) is less or equal to the\n            // number of the last BLOB cached locally.\"\n            throw new Error(`Latest BLOB no. \"${payload.no}\" is not greater than previous ${no}`);\n        }\n        const headerCertsPEM = header.x5c.map(convertCertBufferToPEM);\n        try {\n            // Validate the certificate chain\n            const rootCerts = SettingsService.getRootCertificates({\n                identifier: 'mds',\n            });\n            await validateCertificatePath(headerCertsPEM, rootCerts);\n        }\n        catch (error) {\n            const _error = error;\n            // From FIDO MDS docs: \"ignore the file if the chain cannot be verified or if one of the\n            // chain certificates is revoked\"\n            throw new Error(`BLOB certificate path could not be validated: ${_error.message}`);\n        }\n        // Verify the BLOB JWT signature\n        const leafCert = headerCertsPEM[0];\n        const verified = await verifyJWT(data, convertPEMToBytes(leafCert));\n        if (!verified) {\n            // From FIDO MDS docs: \"The FIDO Server SHOULD ignore the file if the signature is invalid.\"\n            throw new Error('BLOB signature could not be verified');\n        }\n        // Cache statements for FIDO2 devices\n        for (const entry of payload.entries) {\n            // Only cache entries with an `aaguid`\n            if (entry.aaguid) {\n                this.statementCache[entry.aaguid] = { entry, url };\n            }\n        }\n        // Remember info about the server so we can refresh later\n        const [year, month, day] = payload.nextUpdate.split('-');\n        this.mdsCache[url] = {\n            ...mds,\n            // Store the payload `no` to make sure we're getting the next BLOB in the sequence\n            no: payload.no,\n            // Convert the nextUpdate property into a Date so we can determine when to re-download\n            nextUpdate: new Date(parseInt(year, 10), \n            // Months need to be zero-indexed\n            parseInt(month, 10) - 1, parseInt(day, 10)),\n        };\n    }\n    /**\n     * A helper method to pause execution until the service is ready\n     */\n    pauseUntilReady() {\n        if (this.state === SERVICE_STATE.READY) {\n            return new Promise((resolve) => {\n                resolve();\n            });\n        }\n        // State isn't ready, so set up polling\n        const readyPromise = new Promise((resolve, reject) => {\n            const totalTimeoutMS = 70000;\n            const intervalMS = 100;\n            let iterations = totalTimeoutMS / intervalMS;\n            // Check service state every `intervalMS` milliseconds\n            const intervalID = globalThis.setInterval(() => {\n                if (iterations < 1) {\n                    clearInterval(intervalID);\n                    reject(`State did not become ready in ${totalTimeoutMS / 1000} seconds`);\n                }\n                else if (this.state === SERVICE_STATE.READY) {\n                    clearInterval(intervalID);\n                    resolve();\n                }\n                iterations -= 1;\n            }, intervalMS);\n        });\n        return readyPromise;\n    }\n    /**\n     * Report service status on change\n     */\n    setState(newState) {\n        this.state = newState;\n        if (newState === SERVICE_STATE.DISABLED) {\n            log('MetadataService is DISABLED');\n        }\n        else if (newState === SERVICE_STATE.REFRESHING) {\n            log('MetadataService is REFRESHING');\n        }\n        else if (newState === SERVICE_STATE.READY) {\n            log('MetadataService is READY');\n        }\n    }\n}\n/**\n * A basic service for coordinating interactions with the FIDO Metadata Service. This includes BLOB\n * download and parsing, and on-demand requesting and caching of individual metadata statements.\n *\n * https://fidoalliance.org/metadata/\n */\nexport const MetadataService = new BaseMetadataService();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2908, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2914, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/metadata/verifyAttestationWithMetadata.js"],"sourcesContent":["import { convertCertBufferToPEM } from '../helpers/convertCertBufferToPEM.js';\nimport { validateCertificatePath } from '../helpers/validateCertificatePath.js';\nimport { decodeCredentialPublicKey } from '../helpers/decodeCredentialPublicKey.js';\nimport { COSEKEYS, COSEKTY, isCOSEPublicKeyEC2, } from '../helpers/cose.js';\n/**\n * Match properties of the authenticator's attestation statement against expected values as\n * registered with the FIDO Alliance Metadata Service\n */\nexport async function verifyAttestationWithMetadata({ statement, credentialPublicKey, x5c, attestationStatementAlg, }) {\n    const { authenticationAlgorithms, authenticatorGetInfo, attestationRootCertificates, } = statement;\n    // Make sure the alg in the attestation statement matches one of the ones specified in metadata\n    const keypairCOSEAlgs = new Set();\n    authenticationAlgorithms.forEach((algSign) => {\n        // Map algSign string to { kty, alg, crv }\n        const algSignCOSEINFO = algSignToCOSEInfoMap[algSign];\n        // Keeping this statement here just in case MDS returns something unexpected\n        if (algSignCOSEINFO) {\n            keypairCOSEAlgs.add(algSignCOSEINFO);\n        }\n    });\n    // Extract the public key's COSE info for comparison\n    const decodedPublicKey = decodeCredentialPublicKey(credentialPublicKey);\n    const kty = decodedPublicKey.get(COSEKEYS.kty);\n    const alg = decodedPublicKey.get(COSEKEYS.alg);\n    if (!kty) {\n        throw new Error('Credential public key was missing kty');\n    }\n    if (!alg) {\n        throw new Error('Credential public key was missing alg');\n    }\n    if (!kty) {\n        throw new Error('Credential public key was missing kty');\n    }\n    // Assume everything is a number because these values should be\n    const publicKeyCOSEInfo = { kty, alg };\n    if (isCOSEPublicKeyEC2(decodedPublicKey)) {\n        const crv = decodedPublicKey.get(COSEKEYS.crv);\n        publicKeyCOSEInfo.crv = crv;\n    }\n    /**\n     * Attempt to match the credential public key's algorithm to one specified in the device's\n     * metadata\n     */\n    let foundMatch = false;\n    for (const keypairAlg of keypairCOSEAlgs) {\n        // Make sure algorithm and key type match\n        if (keypairAlg.alg === publicKeyCOSEInfo.alg &&\n            keypairAlg.kty === publicKeyCOSEInfo.kty) {\n            // If not an RSA keypair then make sure curve numbers match too\n            if ((keypairAlg.kty === COSEKTY.EC2 || keypairAlg.kty === COSEKTY.OKP) &&\n                keypairAlg.crv === publicKeyCOSEInfo.crv) {\n                foundMatch = true;\n            }\n            else {\n                // We've matched an RSA public key's properties\n                foundMatch = true;\n            }\n        }\n        if (foundMatch) {\n            break;\n        }\n    }\n    // Make sure the public key is one of the allowed algorithms\n    if (!foundMatch) {\n        /**\n         * Craft some useful error output from the MDS algorithms\n         *\n         * Example:\n         *\n         * ```\n         * [\n         *   'rsassa_pss_sha256_raw' (COSE info: { kty: 3, alg: -37 }),\n         *   'secp256k1_ecdsa_sha256_raw' (COSE info: { kty: 2, alg: -47, crv: 8 })\n         * ]\n         * ```\n         */\n        const debugMDSAlgs = authenticationAlgorithms.map((algSign) => `'${algSign}' (COSE info: ${stringifyCOSEInfo(algSignToCOSEInfoMap[algSign])})`);\n        const strMDSAlgs = JSON.stringify(debugMDSAlgs, null, 2).replace(/\"/g, '');\n        /**\n         * Construct useful error output about the public key\n         */\n        const strPubKeyAlg = stringifyCOSEInfo(publicKeyCOSEInfo);\n        throw new Error(`Public key parameters ${strPubKeyAlg} did not match any of the following metadata algorithms:\\n${strMDSAlgs}`);\n    }\n    /**\n     * Confirm the attestation statement's algorithm is one supported according to metadata\n     */\n    if (attestationStatementAlg !== undefined &&\n        authenticatorGetInfo?.algorithms !== undefined) {\n        const getInfoAlgs = authenticatorGetInfo.algorithms.map((_alg) => _alg.alg);\n        if (getInfoAlgs.indexOf(attestationStatementAlg) < 0) {\n            throw new Error(`Attestation statement alg ${attestationStatementAlg} did not match one of ${getInfoAlgs}`);\n        }\n    }\n    // Prepare to check the certificate chain\n    const authenticatorCerts = x5c.map(convertCertBufferToPEM);\n    const statementRootCerts = attestationRootCertificates.map(convertCertBufferToPEM);\n    /**\n     * If an authenticator returns exactly one certificate in its x5c, and that cert is found in the\n     * metadata statement then the authenticator is \"self-referencing\". In this case we forego\n     * certificate chain validation.\n     */\n    let authenticatorIsSelfReferencing = false;\n    if (authenticatorCerts.length === 1 &&\n        statementRootCerts.indexOf(authenticatorCerts[0]) >= 0) {\n        authenticatorIsSelfReferencing = true;\n    }\n    if (!authenticatorIsSelfReferencing) {\n        try {\n            await validateCertificatePath(authenticatorCerts, statementRootCerts);\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`Could not validate certificate path with any metadata root certificates: ${_err.message}`);\n        }\n    }\n    return true;\n}\n/**\n * Convert ALG_SIGN values to COSE info\n *\n * Values pulled from `ALG_KEY_COSE` definitions in the FIDO Registry of Predefined Values\n *\n * https://fidoalliance.org/specs/common-specs/fido-registry-v2.2-ps-20220523.html#authentication-algorithms\n */\nexport const algSignToCOSEInfoMap = {\n    secp256r1_ecdsa_sha256_raw: { kty: 2, alg: -7, crv: 1 },\n    secp256r1_ecdsa_sha256_der: { kty: 2, alg: -7, crv: 1 },\n    rsassa_pss_sha256_raw: { kty: 3, alg: -37 },\n    rsassa_pss_sha256_der: { kty: 3, alg: -37 },\n    secp256k1_ecdsa_sha256_raw: { kty: 2, alg: -47, crv: 8 },\n    secp256k1_ecdsa_sha256_der: { kty: 2, alg: -47, crv: 8 },\n    rsassa_pss_sha384_raw: { kty: 3, alg: -38 },\n    rsassa_pkcsv15_sha256_raw: { kty: 3, alg: -257 },\n    rsassa_pkcsv15_sha384_raw: { kty: 3, alg: -258 },\n    rsassa_pkcsv15_sha512_raw: { kty: 3, alg: -259 },\n    rsassa_pkcsv15_sha1_raw: { kty: 3, alg: -65535 },\n    secp384r1_ecdsa_sha384_raw: { kty: 2, alg: -35, crv: 2 },\n    secp512r1_ecdsa_sha256_raw: { kty: 2, alg: -36, crv: 3 },\n    ed25519_eddsa_sha512_raw: { kty: 1, alg: -8, crv: 6 },\n};\n/**\n * A helper to format COSEInfo a little nicer than we can achieve with JSON.stringify()\n *\n * Input: `{ \"kty\": 3, \"alg\": -257 }`\n *\n * Output: `\"{ kty: 3, alg: -257 }\"`\n */\nfunction stringifyCOSEInfo(info) {\n    const { kty, alg, crv } = info;\n    let toReturn = '';\n    if (kty !== COSEKTY.RSA) {\n        toReturn = `{ kty: ${kty}, alg: ${alg}, crv: ${crv} }`;\n    }\n    else {\n        toReturn = `{ kty: ${kty}, alg: ${alg} }`;\n    }\n    return toReturn;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3109, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3115, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/verifyAttestationPacked.js"],"sourcesContent":["import { isCOSEAlg } from '../../helpers/cose.js';\nimport { convertCertBufferToPEM } from '../../helpers/convertCertBufferToPEM.js';\nimport { validateCertificatePath } from '../../helpers/validateCertificatePath.js';\nimport { getCertificateInfo } from '../../helpers/getCertificateInfo.js';\nimport { verifySignature } from '../../helpers/verifySignature.js';\nimport { isoUint8Array } from '../../helpers/iso/index.js';\nimport { validateExtFIDOGenCEAAGUID } from '../../helpers/validateExtFIDOGenCEAAGUID.js';\nimport { MetadataService } from '../../services/metadataService.js';\nimport { verifyAttestationWithMetadata } from '../../metadata/verifyAttestationWithMetadata.js';\n/**\n * Verify an attestation response with fmt 'packed'\n */\nexport async function verifyAttestationPacked(options) {\n    const { attStmt, clientDataHash, authData, credentialPublicKey, aaguid, rootCertificates, } = options;\n    const sig = attStmt.get('sig');\n    const x5c = attStmt.get('x5c');\n    const alg = attStmt.get('alg');\n    if (!sig) {\n        throw new Error('No attestation signature provided in attestation statement (Packed)');\n    }\n    if (!alg) {\n        throw new Error('Attestation statement did not contain alg (Packed)');\n    }\n    if (!isCOSEAlg(alg)) {\n        throw new Error(`Attestation statement contained invalid alg ${alg} (Packed)`);\n    }\n    const signatureBase = isoUint8Array.concat([authData, clientDataHash]);\n    let verified = false;\n    if (x5c) {\n        const { subject, basicConstraintsCA, version, notBefore, notAfter, parsedCertificate, } = getCertificateInfo(x5c[0]);\n        const { OU, CN, O, C } = subject;\n        if (OU !== 'Authenticator Attestation') {\n            throw new Error('Certificate OU was not \"Authenticator Attestation\" (Packed|Full)');\n        }\n        if (!CN) {\n            throw new Error('Certificate CN was empty (Packed|Full)');\n        }\n        if (!O) {\n            throw new Error('Certificate O was empty (Packed|Full)');\n        }\n        if (!C || C.length !== 2) {\n            throw new Error('Certificate C was not two-character ISO 3166 code (Packed|Full)');\n        }\n        if (basicConstraintsCA) {\n            throw new Error('Certificate basic constraints CA was not `false` (Packed|Full)');\n        }\n        if (version !== 2) {\n            throw new Error('Certificate version was not `3` (ASN.1 value of 2) (Packed|Full)');\n        }\n        let now = new Date();\n        if (notBefore > now) {\n            throw new Error(`Certificate not good before \"${notBefore.toString()}\" (Packed|Full)`);\n        }\n        now = new Date();\n        if (notAfter < now) {\n            throw new Error(`Certificate not good after \"${notAfter.toString()}\" (Packed|Full)`);\n        }\n        // Validate attestation statement AAGUID against leaf cert AAGUID\n        try {\n            await validateExtFIDOGenCEAAGUID(parsedCertificate.tbsCertificate.extensions, aaguid);\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (Packed|Full)`);\n        }\n        // If available, validate attestation alg and x5c with info in the metadata statement\n        const statement = await MetadataService.getStatement(aaguid);\n        if (statement) {\n            // The presence of x5c means this is a full attestation. Check to see if attestationTypes\n            // includes packed attestations.\n            if (statement.attestationTypes.indexOf('basic_full') < 0) {\n                throw new Error('Metadata does not indicate support for full attestations (Packed|Full)');\n            }\n            try {\n                await verifyAttestationWithMetadata({\n                    statement,\n                    credentialPublicKey,\n                    x5c,\n                    attestationStatementAlg: alg,\n                });\n            }\n            catch (err) {\n                const _err = err;\n                throw new Error(`${_err.message} (Packed|Full)`);\n            }\n        }\n        else {\n            try {\n                // Try validating the certificate path using the root certificates set via SettingsService\n                await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);\n            }\n            catch (err) {\n                const _err = err;\n                throw new Error(`${_err.message} (Packed|Full)`);\n            }\n        }\n        verified = await verifySignature({\n            signature: sig,\n            data: signatureBase,\n            x509Certificate: x5c[0],\n        });\n    }\n    else {\n        verified = await verifySignature({\n            signature: sig,\n            data: signatureBase,\n            credentialPublicKey,\n            hashAlgorithm: alg,\n        });\n    }\n    return verified;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3235, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3241, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidSafetyNet.js"],"sourcesContent":["import { toHash } from '../../helpers/toHash.js';\nimport { verifySignature } from '../../helpers/verifySignature.js';\nimport { getCertificateInfo } from '../../helpers/getCertificateInfo.js';\nimport { validateCertificatePath } from '../../helpers/validateCertificatePath.js';\nimport { convertCertBufferToPEM } from '../../helpers/convertCertBufferToPEM.js';\nimport { isoBase64URL, isoUint8Array } from '../../helpers/iso/index.js';\nimport { MetadataService } from '../../services/metadataService.js';\nimport { verifyAttestationWithMetadata } from '../../metadata/verifyAttestationWithMetadata.js';\n/**\n * Verify an attestation response with fmt 'android-safetynet'\n */\nexport async function verifyAttestationAndroidSafetyNet(options) {\n    const { attStmt, clientDataHash, authData, aaguid, rootCertificates, verifyTimestampMS = true, credentialPublicKey, } = options;\n    const alg = attStmt.get('alg');\n    const response = attStmt.get('response');\n    const ver = attStmt.get('ver');\n    if (!ver) {\n        throw new Error('No ver value in attestation (SafetyNet)');\n    }\n    if (!response) {\n        throw new Error('No response was included in attStmt by authenticator (SafetyNet)');\n    }\n    // Prepare to verify a JWT\n    const jwt = isoUint8Array.toUTF8String(response);\n    const jwtParts = jwt.split('.');\n    const HEADER = JSON.parse(isoBase64URL.toUTF8String(jwtParts[0]));\n    const PAYLOAD = JSON.parse(isoBase64URL.toUTF8String(jwtParts[1]));\n    const SIGNATURE = jwtParts[2];\n    /**\n     * START Verify PAYLOAD\n     */\n    const { nonce, ctsProfileMatch, timestampMs } = PAYLOAD;\n    if (verifyTimestampMS) {\n        // Make sure timestamp is in the past\n        let now = Date.now();\n        if (timestampMs > Date.now()) {\n            throw new Error(`Payload timestamp \"${timestampMs}\" was later than \"${now}\" (SafetyNet)`);\n        }\n        // Consider a SafetyNet attestation valid within a minute of it being performed\n        const timestampPlusDelay = timestampMs + 60 * 1000;\n        now = Date.now();\n        if (timestampPlusDelay < now) {\n            throw new Error(`Payload timestamp \"${timestampPlusDelay}\" has expired (SafetyNet)`);\n        }\n    }\n    const nonceBase = isoUint8Array.concat([authData, clientDataHash]);\n    const nonceBuffer = await toHash(nonceBase);\n    const expectedNonce = isoBase64URL.fromBuffer(nonceBuffer, 'base64');\n    if (nonce !== expectedNonce) {\n        throw new Error('Could not verify payload nonce (SafetyNet)');\n    }\n    if (!ctsProfileMatch) {\n        throw new Error('Could not verify device integrity (SafetyNet)');\n    }\n    /**\n     * END Verify PAYLOAD\n     */\n    /**\n     * START Verify Header\n     */\n    // `HEADER.x5c[0]` is definitely a base64 string\n    const leafCertBuffer = isoBase64URL.toBuffer(HEADER.x5c[0], 'base64');\n    const leafCertInfo = getCertificateInfo(leafCertBuffer);\n    const { subject } = leafCertInfo;\n    // Ensure the certificate was issued to this hostname\n    // See https://developer.android.com/training/safetynet/attestation#verify-attestation-response\n    if (subject.CN !== 'attest.android.com') {\n        throw new Error('Certificate common name was not \"attest.android.com\" (SafetyNet)');\n    }\n    const statement = await MetadataService.getStatement(aaguid);\n    if (statement) {\n        try {\n            await verifyAttestationWithMetadata({\n                statement,\n                credentialPublicKey,\n                x5c: HEADER.x5c,\n                attestationStatementAlg: alg,\n            });\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (SafetyNet)`);\n        }\n    }\n    else {\n        try {\n            // Try validating the certificate path using the root certificates set via SettingsService\n            await validateCertificatePath(HEADER.x5c.map(convertCertBufferToPEM), rootCertificates);\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (SafetyNet)`);\n        }\n    }\n    /**\n     * END Verify Header\n     */\n    /**\n     * START Verify Signature\n     */\n    const signatureBaseBuffer = isoUint8Array.fromUTF8String(`${jwtParts[0]}.${jwtParts[1]}`);\n    const signatureBuffer = isoBase64URL.toBuffer(SIGNATURE);\n    const verified = await verifySignature({\n        signature: signatureBuffer,\n        data: signatureBaseBuffer,\n        x509Certificate: leafCertBuffer,\n    });\n    /**\n     * END Verify Signature\n     */\n    return verified;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3357, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3363, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/tpm/constants.js"],"sourcesContent":["// deno-lint-ignore-file no-dupe-keys\n/**\n * A whole lotta domain knowledge is captured here, with hazy connections to source\n * documents. Good places to start searching for more info on these values are the\n * following Trusted Computing Group TPM Library docs linked in the WebAuthn API:\n *\n * - https://www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-1-Architecture-01.38.pdf\n * - https://www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-01.38.pdf\n * - https://www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-3-Commands-01.38.pdf\n */\n/**\n * 6.9 TPM_ST (Structure Tags)\n */\nexport const TPM_ST = {\n    0x00c4: 'TPM_ST_RSP_COMMAND',\n    0x8000: 'TPM_ST_NULL',\n    0x8001: 'TPM_ST_NO_SESSIONS',\n    0x8002: 'TPM_ST_SESSIONS',\n    0x8014: 'TPM_ST_ATTEST_NV',\n    0x8015: 'TPM_ST_ATTEST_COMMAND_AUDIT',\n    0x8016: 'TPM_ST_ATTEST_SESSION_AUDIT',\n    0x8017: 'TPM_ST_ATTEST_CERTIFY',\n    0x8018: 'TPM_ST_ATTEST_QUOTE',\n    0x8019: 'TPM_ST_ATTEST_TIME',\n    0x801a: 'TPM_ST_ATTEST_CREATION',\n    0x8021: 'TPM_ST_CREATION',\n    0x8022: 'TPM_ST_VERIFIED',\n    0x8023: 'TPM_ST_AUTH_SECRET',\n    0x8024: 'TPM_ST_HASHCHECK',\n    0x8025: 'TPM_ST_AUTH_SIGNED',\n    0x8029: 'TPM_ST_FU_MANIFEST',\n};\n/**\n * 6.3 TPM_ALG_ID\n */\nexport const TPM_ALG = {\n    0x0000: 'TPM_ALG_ERROR',\n    0x0001: 'TPM_ALG_RSA',\n    0x0004: 'TPM_ALG_SHA',\n    // @ts-ignore 2300\n    0x0004: 'TPM_ALG_SHA1',\n    0x0005: 'TPM_ALG_HMAC',\n    0x0006: 'TPM_ALG_AES',\n    0x0007: 'TPM_ALG_MGF1',\n    0x0008: 'TPM_ALG_KEYEDHASH',\n    0x000a: 'TPM_ALG_XOR',\n    0x000b: 'TPM_ALG_SHA256',\n    0x000c: 'TPM_ALG_SHA384',\n    0x000d: 'TPM_ALG_SHA512',\n    0x0010: 'TPM_ALG_NULL',\n    0x0012: 'TPM_ALG_SM3_256',\n    0x0013: 'TPM_ALG_SM4',\n    0x0014: 'TPM_ALG_RSASSA',\n    0x0015: 'TPM_ALG_RSAES',\n    0x0016: 'TPM_ALG_RSAPSS',\n    0x0017: 'TPM_ALG_OAEP',\n    0x0018: 'TPM_ALG_ECDSA',\n    0x0019: 'TPM_ALG_ECDH',\n    0x001a: 'TPM_ALG_ECDAA',\n    0x001b: 'TPM_ALG_SM2',\n    0x001c: 'TPM_ALG_ECSCHNORR',\n    0x001d: 'TPM_ALG_ECMQV',\n    0x0020: 'TPM_ALG_KDF1_SP800_56A',\n    0x0021: 'TPM_ALG_KDF2',\n    0x0022: 'TPM_ALG_KDF1_SP800_108',\n    0x0023: 'TPM_ALG_ECC',\n    0x0025: 'TPM_ALG_SYMCIPHER',\n    0x0026: 'TPM_ALG_CAMELLIA',\n    0x0040: 'TPM_ALG_CTR',\n    0x0041: 'TPM_ALG_OFB',\n    0x0042: 'TPM_ALG_CBC',\n    0x0043: 'TPM_ALG_CFB',\n    0x0044: 'TPM_ALG_ECB',\n};\n/**\n * 6.4 TPM_ECC_CURVE\n */\nexport const TPM_ECC_CURVE = {\n    0x0000: 'TPM_ECC_NONE',\n    0x0001: 'TPM_ECC_NIST_P192',\n    0x0002: 'TPM_ECC_NIST_P224',\n    0x0003: 'TPM_ECC_NIST_P256',\n    0x0004: 'TPM_ECC_NIST_P384',\n    0x0005: 'TPM_ECC_NIST_P521',\n    0x0010: 'TPM_ECC_BN_P256',\n    0x0011: 'TPM_ECC_BN_P638',\n    0x0020: 'TPM_ECC_SM2_P256',\n};\n/**\n * Sourced from https://trustedcomputinggroup.org/resource/vendor-id-registry/\n *\n * Latest version:\n * https://trustedcomputinggroup.org/wp-content/uploads/TCG-TPM-Vendor-ID-Registry-Version-1.02-Revision-1.00.pdf\n */\nexport const TPM_MANUFACTURERS = {\n    'id:414D4400': { name: 'AMD', id: 'AMD' },\n    'id:414E5400': { name: 'Ant Group', id: 'ANT' },\n    'id:41544D4C': { name: 'Atmel', id: 'ATML' },\n    'id:4252434D': { name: 'Broadcom', id: 'BRCM' },\n    'id:4353434F': { name: 'Cisco', id: 'CSCO' },\n    'id:464C5953': { name: 'Flyslice Technologies', id: 'FLYS' },\n    'id:524F4343': { name: 'Fuzhou Rockchip', id: 'ROCC' },\n    'id:474F4F47': { name: 'Google', id: 'GOOG' },\n    'id:48504900': { name: 'HPI', id: 'HPI' },\n    'id:48504500': { name: 'HPE', id: 'HPE' },\n    'id:48495349': { name: 'Huawei', id: 'HISI' },\n    'id:49424d00': { name: 'IBM', id: 'IBM' },\n    'id:49424D00': { name: 'IBM', id: 'IBM' }, // Same ID for IBM as above, except the \"D\" is capitalized as per TPM spec\n    'id:49465800': { name: 'Infineon', id: 'IFX' },\n    'id:494E5443': { name: 'Intel', id: 'INTC' },\n    'id:4C454E00': { name: 'Lenovo', id: 'LEN' },\n    'id:4D534654': { name: 'Microsoft', id: 'MSFT' },\n    'id:4E534D20': { name: 'National Semiconductor', id: 'NSM' },\n    'id:4E545A00': { name: 'Nationz', id: 'NTZ' },\n    'id:4E534700': { name: 'NSING', id: 'NSG' },\n    'id:4E544300': { name: 'Nuvoton Technology', id: 'NTC' },\n    'id:51434F4D': { name: 'Qualcomm', id: 'QCOM' },\n    'id:534D534E': { name: 'Samsung', id: 'SMSN' },\n    'id:53454345': { name: 'SecEdge', id: 'SECE' },\n    'id:534E5300': { name: 'Sinosun', id: 'SNS' },\n    'id:534D5343': { name: 'SMSC', id: 'SMSC' },\n    'id:53544D20': { name: 'STMicroelectronics', id: 'STM' },\n    'id:54584E00': { name: 'Texas Instruments', id: 'TXN' },\n    'id:57454300': { name: 'Winbond', id: 'WEC' },\n    'id:5345414C': { name: 'Wisekey', id: 'SEAL' },\n    'id:FFFFF1D0': { name: 'FIDO Alliance', id: 'FIDO' }, // FIDO Conformance\n};\n/**\n * Match TPM public area curve ID's to `crv` numbers used in COSE public keys\n */\nexport const TPM_ECC_CURVE_COSE_CRV_MAP = {\n    TPM_ECC_NIST_P256: 1, // p256\n    TPM_ECC_NIST_P384: 2, // p384\n    TPM_ECC_NIST_P521: 3, // p521\n    TPM_ECC_BN_P256: 1, // p256\n    TPM_ECC_SM2_P256: 1, // p256\n};\n"],"names":[],"mappings":"AAAA,qCAAqC;AACrC;;;;;;;;CAQC,GACD;;CAEC;;;;;;;AACM,MAAM,SAAS;IAClB,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;AACZ;AAIO,MAAM,UAAU;IACnB,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,kBAAkB;IAClB,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;AACZ;AAIO,MAAM,gBAAgB;IACzB,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;AACZ;AAOO,MAAM,oBAAoB;IAC7B,eAAe;QAAE,MAAM;QAAO,IAAI;IAAM;IACxC,eAAe;QAAE,MAAM;QAAa,IAAI;IAAM;IAC9C,eAAe;QAAE,MAAM;QAAS,IAAI;IAAO;IAC3C,eAAe;QAAE,MAAM;QAAY,IAAI;IAAO;IAC9C,eAAe;QAAE,MAAM;QAAS,IAAI;IAAO;IAC3C,eAAe;QAAE,MAAM;QAAyB,IAAI;IAAO;IAC3D,eAAe;QAAE,MAAM;QAAmB,IAAI;IAAO;IACrD,eAAe;QAAE,MAAM;QAAU,IAAI;IAAO;IAC5C,eAAe;QAAE,MAAM;QAAO,IAAI;IAAM;IACxC,eAAe;QAAE,MAAM;QAAO,IAAI;IAAM;IACxC,eAAe;QAAE,MAAM;QAAU,IAAI;IAAO;IAC5C,eAAe;QAAE,MAAM;QAAO,IAAI;IAAM;IACxC,eAAe;QAAE,MAAM;QAAO,IAAI;IAAM;IACxC,eAAe;QAAE,MAAM;QAAY,IAAI;IAAM;IAC7C,eAAe;QAAE,MAAM;QAAS,IAAI;IAAO;IAC3C,eAAe;QAAE,MAAM;QAAU,IAAI;IAAM;IAC3C,eAAe;QAAE,MAAM;QAAa,IAAI;IAAO;IAC/C,eAAe;QAAE,MAAM;QAA0B,IAAI;IAAM;IAC3D,eAAe;QAAE,MAAM;QAAW,IAAI;IAAM;IAC5C,eAAe;QAAE,MAAM;QAAS,IAAI;IAAM;IAC1C,eAAe;QAAE,MAAM;QAAsB,IAAI;IAAM;IACvD,eAAe;QAAE,MAAM;QAAY,IAAI;IAAO;IAC9C,eAAe;QAAE,MAAM;QAAW,IAAI;IAAO;IAC7C,eAAe;QAAE,MAAM;QAAW,IAAI;IAAO;IAC7C,eAAe;QAAE,MAAM;QAAW,IAAI;IAAM;IAC5C,eAAe;QAAE,MAAM;QAAQ,IAAI;IAAO;IAC1C,eAAe;QAAE,MAAM;QAAsB,IAAI;IAAM;IACvD,eAAe;QAAE,MAAM;QAAqB,IAAI;IAAM;IACtD,eAAe;QAAE,MAAM;QAAW,IAAI;IAAM;IAC5C,eAAe;QAAE,MAAM;QAAW,IAAI;IAAO;IAC7C,eAAe;QAAE,MAAM;QAAiB,IAAI;IAAO;AACvD;AAIO,MAAM,6BAA6B;IACtC,mBAAmB;IACnB,mBAAmB;IACnB,mBAAmB;IACnB,iBAAiB;IACjB,kBAAkB;AACtB","ignoreList":[0]}},
    {"offset": {"line": 3583, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3589, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/tpm/parseCertInfo.js"],"sourcesContent":["import { TPM_ALG, TPM_ST } from './constants.js';\nimport { isoUint8Array } from '../../../helpers/iso/index.js';\n/**\n * Cut up a TPM attestation's certInfo into intelligible chunks\n */\nexport function parseCertInfo(certInfo) {\n    let pointer = 0;\n    const dataView = isoUint8Array.toDataView(certInfo);\n    // Get a magic constant\n    const magic = dataView.getUint32(pointer);\n    pointer += 4;\n    // Determine the algorithm used for attestation\n    const typeBuffer = dataView.getUint16(pointer);\n    pointer += 2;\n    const type = TPM_ST[typeBuffer];\n    // The name of a parent entity, can be ignored\n    const qualifiedSignerLength = dataView.getUint16(pointer);\n    pointer += 2;\n    const qualifiedSigner = certInfo.slice(pointer, pointer += qualifiedSignerLength);\n    // Get the expected hash of `attsToBeSigned`\n    const extraDataLength = dataView.getUint16(pointer);\n    pointer += 2;\n    const extraData = certInfo.slice(pointer, pointer += extraDataLength);\n    // Information about the TPM device's internal clock, can be ignored\n    const clock = certInfo.slice(pointer, pointer += 8);\n    const resetCount = dataView.getUint32(pointer);\n    pointer += 4;\n    const restartCount = dataView.getUint32(pointer);\n    pointer += 4;\n    const safe = !!certInfo.slice(pointer, pointer += 1);\n    const clockInfo = { clock, resetCount, restartCount, safe };\n    // TPM device firmware version\n    const firmwareVersion = certInfo.slice(pointer, pointer += 8);\n    // Attested Name\n    const attestedNameLength = dataView.getUint16(pointer);\n    pointer += 2;\n    const attestedName = certInfo.slice(pointer, pointer += attestedNameLength);\n    const attestedNameDataView = isoUint8Array.toDataView(attestedName);\n    // Attested qualified name, can be ignored\n    const qualifiedNameLength = dataView.getUint16(pointer);\n    pointer += 2;\n    const qualifiedName = certInfo.slice(pointer, pointer += qualifiedNameLength);\n    const attested = {\n        nameAlg: TPM_ALG[attestedNameDataView.getUint16(0)],\n        nameAlgBuffer: attestedName.slice(0, 2),\n        name: attestedName,\n        qualifiedName,\n    };\n    return {\n        magic,\n        type,\n        qualifiedSigner,\n        extraData,\n        clockInfo,\n        firmwareVersion,\n        attested,\n    };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AAAA;;;AAIO,SAAS,cAAc,QAAQ;IAClC,IAAI,UAAU;IACd,MAAM,WAAW,uSAAA,CAAA,gBAAa,CAAC,UAAU,CAAC;IAC1C,uBAAuB;IACvB,MAAM,QAAQ,SAAS,SAAS,CAAC;IACjC,WAAW;IACX,+CAA+C;IAC/C,MAAM,aAAa,SAAS,SAAS,CAAC;IACtC,WAAW;IACX,MAAM,OAAO,gRAAA,CAAA,SAAM,CAAC,WAAW;IAC/B,8CAA8C;IAC9C,MAAM,wBAAwB,SAAS,SAAS,CAAC;IACjD,WAAW;IACX,MAAM,kBAAkB,SAAS,KAAK,CAAC,SAAS,WAAW;IAC3D,4CAA4C;IAC5C,MAAM,kBAAkB,SAAS,SAAS,CAAC;IAC3C,WAAW;IACX,MAAM,YAAY,SAAS,KAAK,CAAC,SAAS,WAAW;IACrD,oEAAoE;IACpE,MAAM,QAAQ,SAAS,KAAK,CAAC,SAAS,WAAW;IACjD,MAAM,aAAa,SAAS,SAAS,CAAC;IACtC,WAAW;IACX,MAAM,eAAe,SAAS,SAAS,CAAC;IACxC,WAAW;IACX,MAAM,OAAO,CAAC,CAAC,SAAS,KAAK,CAAC,SAAS,WAAW;IAClD,MAAM,YAAY;QAAE;QAAO;QAAY;QAAc;IAAK;IAC1D,8BAA8B;IAC9B,MAAM,kBAAkB,SAAS,KAAK,CAAC,SAAS,WAAW;IAC3D,gBAAgB;IAChB,MAAM,qBAAqB,SAAS,SAAS,CAAC;IAC9C,WAAW;IACX,MAAM,eAAe,SAAS,KAAK,CAAC,SAAS,WAAW;IACxD,MAAM,uBAAuB,uSAAA,CAAA,gBAAa,CAAC,UAAU,CAAC;IACtD,0CAA0C;IAC1C,MAAM,sBAAsB,SAAS,SAAS,CAAC;IAC/C,WAAW;IACX,MAAM,gBAAgB,SAAS,KAAK,CAAC,SAAS,WAAW;IACzD,MAAM,WAAW;QACb,SAAS,gRAAA,CAAA,UAAO,CAAC,qBAAqB,SAAS,CAAC,GAAG;QACnD,eAAe,aAAa,KAAK,CAAC,GAAG;QACrC,MAAM;QACN;IACJ;IACA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 3655, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3661, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/tpm/parsePubArea.js"],"sourcesContent":["import { TPM_ALG, TPM_ECC_CURVE } from './constants.js';\nimport { isoUint8Array } from '../../../helpers/iso/index.js';\n/**\n * Break apart a TPM attestation's pubArea buffer\n *\n * See 12.2.4 TPMT_PUBLIC here:\n * https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-00.96-130315.pdf\n */\nexport function parsePubArea(pubArea) {\n    let pointer = 0;\n    const dataView = isoUint8Array.toDataView(pubArea);\n    const type = TPM_ALG[dataView.getUint16(pointer)];\n    pointer += 2;\n    const nameAlg = TPM_ALG[dataView.getUint16(pointer)];\n    pointer += 2;\n    // Get some authenticator attributes(?)\n    // const objectAttributesInt = pubArea.slice(pointer, (pointer += 4)).readUInt32BE(0);\n    const objectAttributesInt = dataView.getUint32(pointer);\n    pointer += 4;\n    const objectAttributes = {\n        fixedTPM: !!(objectAttributesInt & 1),\n        stClear: !!(objectAttributesInt & 2),\n        fixedParent: !!(objectAttributesInt & 8),\n        sensitiveDataOrigin: !!(objectAttributesInt & 16),\n        userWithAuth: !!(objectAttributesInt & 32),\n        adminWithPolicy: !!(objectAttributesInt & 64),\n        noDA: !!(objectAttributesInt & 512),\n        encryptedDuplication: !!(objectAttributesInt & 1024),\n        restricted: !!(objectAttributesInt & 32768),\n        decrypt: !!(objectAttributesInt & 65536),\n        signOrEncrypt: !!(objectAttributesInt & 131072),\n    };\n    // Slice out the authPolicy of dynamic length\n    const authPolicyLength = dataView.getUint16(pointer);\n    pointer += 2;\n    const authPolicy = pubArea.slice(pointer, pointer += authPolicyLength);\n    // Extract additional curve params according to type\n    const parameters = {};\n    let unique = Uint8Array.from([]);\n    if (type === 'TPM_ALG_RSA') {\n        const symmetric = TPM_ALG[dataView.getUint16(pointer)];\n        pointer += 2;\n        const scheme = TPM_ALG[dataView.getUint16(pointer)];\n        pointer += 2;\n        const keyBits = dataView.getUint16(pointer);\n        pointer += 2;\n        const exponent = dataView.getUint32(pointer);\n        pointer += 4;\n        parameters.rsa = { symmetric, scheme, keyBits, exponent };\n        /**\n         * See 11.2.4.5 TPM2B_PUBLIC_KEY_RSA here:\n         * https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-00.96-130315.pdf\n         */\n        // const uniqueLength = pubArea.slice(pointer, (pointer += 2)).readUInt16BE(0);\n        const uniqueLength = dataView.getUint16(pointer);\n        pointer += 2;\n        unique = pubArea.slice(pointer, pointer += uniqueLength);\n    }\n    else if (type === 'TPM_ALG_ECC') {\n        const symmetric = TPM_ALG[dataView.getUint16(pointer)];\n        pointer += 2;\n        const scheme = TPM_ALG[dataView.getUint16(pointer)];\n        pointer += 2;\n        const curveID = TPM_ECC_CURVE[dataView.getUint16(pointer)];\n        pointer += 2;\n        const kdf = TPM_ALG[dataView.getUint16(pointer)];\n        pointer += 2;\n        parameters.ecc = { symmetric, scheme, curveID, kdf };\n        /**\n         * See 11.2.5.1 TPM2B_ECC_PARAMETER here:\n         * https://trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-00.96-130315.pdf\n         */\n        // Retrieve X\n        const uniqueXLength = dataView.getUint16(pointer);\n        pointer += 2;\n        const uniqueX = pubArea.slice(pointer, pointer += uniqueXLength);\n        // Retrieve Y\n        const uniqueYLength = dataView.getUint16(pointer);\n        pointer += 2;\n        const uniqueY = pubArea.slice(pointer, pointer += uniqueYLength);\n        unique = isoUint8Array.concat([uniqueX, uniqueY]);\n    }\n    else {\n        throw new Error(`Unexpected type \"${type}\" (TPM)`);\n    }\n    return {\n        type,\n        nameAlg,\n        objectAttributes,\n        authPolicy,\n        parameters,\n        unique,\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3764, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3770, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/tpm/verifyAttestationTPM.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { Certificate, ExtendedKeyUsage, id_ce_extKeyUsage, id_ce_subjectAltName, SubjectAlternativeName, } from '@peculiar/asn1-x509';\nimport { decodeCredentialPublicKey } from '../../../helpers/decodeCredentialPublicKey.js';\nimport { COSEALG, COSEKEYS, isCOSEAlg, isCOSEPublicKeyEC2, isCOSEPublicKeyRSA, } from '../../../helpers/cose.js';\nimport { toHash } from '../../../helpers/toHash.js';\nimport { convertCertBufferToPEM } from '../../../helpers/convertCertBufferToPEM.js';\nimport { validateCertificatePath } from '../../../helpers/validateCertificatePath.js';\nimport { getCertificateInfo } from '../../../helpers/getCertificateInfo.js';\nimport { verifySignature } from '../../../helpers/verifySignature.js';\nimport { isoUint8Array } from '../../../helpers/iso/index.js';\nimport { validateExtFIDOGenCEAAGUID } from '../../../helpers/validateExtFIDOGenCEAAGUID.js';\nimport { MetadataService } from '../../../services/metadataService.js';\nimport { verifyAttestationWithMetadata } from '../../../metadata/verifyAttestationWithMetadata.js';\nimport { TPM_ECC_CURVE_COSE_CRV_MAP, TPM_MANUFACTURERS } from './constants.js';\nimport { parseCertInfo } from './parseCertInfo.js';\nimport { parsePubArea } from './parsePubArea.js';\nexport async function verifyAttestationTPM(options) {\n    const { aaguid, attStmt, authData, credentialPublicKey, clientDataHash, rootCertificates, } = options;\n    const ver = attStmt.get('ver');\n    const sig = attStmt.get('sig');\n    const alg = attStmt.get('alg');\n    const x5c = attStmt.get('x5c');\n    const pubArea = attStmt.get('pubArea');\n    const certInfo = attStmt.get('certInfo');\n    /**\n     * Verify structures\n     */\n    if (ver !== '2.0') {\n        throw new Error(`Unexpected ver \"${ver}\", expected \"2.0\" (TPM)`);\n    }\n    if (!sig) {\n        throw new Error('No attestation signature provided in attestation statement (TPM)');\n    }\n    if (!alg) {\n        throw new Error(`Attestation statement did not contain alg (TPM)`);\n    }\n    if (!isCOSEAlg(alg)) {\n        throw new Error(`Attestation statement contained invalid alg ${alg} (TPM)`);\n    }\n    if (!x5c) {\n        throw new Error('No attestation certificate provided in attestation statement (TPM)');\n    }\n    if (!pubArea) {\n        throw new Error('Attestation statement did not contain pubArea (TPM)');\n    }\n    if (!certInfo) {\n        throw new Error('Attestation statement did not contain certInfo (TPM)');\n    }\n    const parsedPubArea = parsePubArea(pubArea);\n    const { unique, type: pubType, parameters } = parsedPubArea;\n    // Verify that the public key specified by the parameters and unique fields of pubArea is\n    // identical to the credentialPublicKey in the attestedCredentialData in authenticatorData.\n    const cosePublicKey = decodeCredentialPublicKey(credentialPublicKey);\n    if (pubType === 'TPM_ALG_RSA') {\n        if (!isCOSEPublicKeyRSA(cosePublicKey)) {\n            throw new Error(`Credential public key with kty ${cosePublicKey.get(COSEKEYS.kty)} did not match ${pubType}`);\n        }\n        const n = cosePublicKey.get(COSEKEYS.n);\n        const e = cosePublicKey.get(COSEKEYS.e);\n        if (!n) {\n            throw new Error('COSE public key missing n (TPM|RSA)');\n        }\n        if (!e) {\n            throw new Error('COSE public key missing e (TPM|RSA)');\n        }\n        if (!isoUint8Array.areEqual(unique, n)) {\n            throw new Error('PubArea unique is not same as credentialPublicKey (TPM|RSA)');\n        }\n        if (!parameters.rsa) {\n            throw new Error(`Parsed pubArea type is RSA, but missing parameters.rsa (TPM|RSA)`);\n        }\n        const eBuffer = e;\n        // If `exponent` is equal to 0x00, then exponent is the default RSA exponent of 2^16+1 (65537)\n        const pubAreaExponent = parameters.rsa.exponent || 65537;\n        // Do some bit shifting to get to an integer\n        const eSum = eBuffer[0] + (eBuffer[1] << 8) + (eBuffer[2] << 16);\n        if (pubAreaExponent !== eSum) {\n            throw new Error(`Unexpected public key exp ${eSum}, expected ${pubAreaExponent} (TPM|RSA)`);\n        }\n    }\n    else if (pubType === 'TPM_ALG_ECC') {\n        if (!isCOSEPublicKeyEC2(cosePublicKey)) {\n            throw new Error(`Credential public key with kty ${cosePublicKey.get(COSEKEYS.kty)} did not match ${pubType}`);\n        }\n        const crv = cosePublicKey.get(COSEKEYS.crv);\n        const x = cosePublicKey.get(COSEKEYS.x);\n        const y = cosePublicKey.get(COSEKEYS.y);\n        if (!crv) {\n            throw new Error('COSE public key missing crv (TPM|ECC)');\n        }\n        if (!x) {\n            throw new Error('COSE public key missing x (TPM|ECC)');\n        }\n        if (!y) {\n            throw new Error('COSE public key missing y (TPM|ECC)');\n        }\n        if (!isoUint8Array.areEqual(unique, isoUint8Array.concat([x, y]))) {\n            throw new Error('PubArea unique is not same as public key x and y (TPM|ECC)');\n        }\n        if (!parameters.ecc) {\n            throw new Error(`Parsed pubArea type is ECC, but missing parameters.ecc (TPM|ECC)`);\n        }\n        const pubAreaCurveID = parameters.ecc.curveID;\n        const pubAreaCurveIDMapToCOSECRV = TPM_ECC_CURVE_COSE_CRV_MAP[pubAreaCurveID];\n        if (pubAreaCurveIDMapToCOSECRV !== crv) {\n            throw new Error(`Public area key curve ID \"${pubAreaCurveID}\" mapped to \"${pubAreaCurveIDMapToCOSECRV}\" which did not match public key crv of \"${crv}\" (TPM|ECC)`);\n        }\n    }\n    else {\n        throw new Error(`Unsupported pubArea.type \"${pubType}\"`);\n    }\n    const parsedCertInfo = parseCertInfo(certInfo);\n    const { magic, type: certType, attested, extraData } = parsedCertInfo;\n    if (magic !== 0xff544347) {\n        throw new Error(`Unexpected magic value \"${magic}\", expected \"0xff544347\" (TPM)`);\n    }\n    if (certType !== 'TPM_ST_ATTEST_CERTIFY') {\n        throw new Error(`Unexpected type \"${certType}\", expected \"TPM_ST_ATTEST_CERTIFY\" (TPM)`);\n    }\n    // Hash pubArea to create pubAreaHash using the nameAlg in attested\n    const pubAreaHash = await toHash(pubArea, attestedNameAlgToCOSEAlg(attested.nameAlg));\n    // Concatenate attested.nameAlg and pubAreaHash to create attestedName.\n    const attestedName = isoUint8Array.concat([\n        attested.nameAlgBuffer,\n        pubAreaHash,\n    ]);\n    // Check that certInfo.attested.name is equals to attestedName.\n    if (!isoUint8Array.areEqual(attested.name, attestedName)) {\n        throw new Error(`Attested name comparison failed (TPM)`);\n    }\n    // Concatenate authData with clientDataHash to create attToBeSigned\n    const attToBeSigned = isoUint8Array.concat([authData, clientDataHash]);\n    // Hash attToBeSigned using the algorithm specified in attStmt.alg to create attToBeSignedHash\n    const attToBeSignedHash = await toHash(attToBeSigned, alg);\n    // Check that certInfo.extraData is equals to attToBeSignedHash.\n    if (!isoUint8Array.areEqual(extraData, attToBeSignedHash)) {\n        throw new Error('CertInfo extra data did not equal hashed attestation (TPM)');\n    }\n    /**\n     * Verify signature\n     */\n    if (x5c.length < 1) {\n        throw new Error('No certificates present in x5c array (TPM)');\n    }\n    // Pick a leaf AIK certificate of the x5c array and parse it.\n    const leafCertInfo = getCertificateInfo(x5c[0]);\n    const { basicConstraintsCA, version, subject, notAfter, notBefore } = leafCertInfo;\n    if (basicConstraintsCA) {\n        throw new Error('Certificate basic constraints CA was not `false` (TPM)');\n    }\n    // Check that certificate is of version 3 (value must be set to 2).\n    if (version !== 2) {\n        throw new Error('Certificate version was not `3` (ASN.1 value of 2) (TPM)');\n    }\n    // Check that Subject sequence is empty.\n    if (subject.combined.length > 0) {\n        throw new Error('Certificate subject was not empty (TPM)');\n    }\n    // Check that certificate is currently valid\n    let now = new Date();\n    if (notBefore > now) {\n        throw new Error(`Certificate not good before \"${notBefore.toString()}\" (TPM)`);\n    }\n    // Check that certificate has not expired\n    now = new Date();\n    if (notAfter < now) {\n        throw new Error(`Certificate not good after \"${notAfter.toString()}\" (TPM)`);\n    }\n    /**\n     * Plumb the depths of the certificate's ASN.1-formatted data for some values we need to verify\n     */\n    const parsedCert = AsnParser.parse(x5c[0], Certificate);\n    if (!parsedCert.tbsCertificate.extensions) {\n        throw new Error('Certificate was missing extensions (TPM)');\n    }\n    let subjectAltNamePresent;\n    let extKeyUsage;\n    parsedCert.tbsCertificate.extensions.forEach((ext) => {\n        if (ext.extnID === id_ce_subjectAltName) {\n            subjectAltNamePresent = AsnParser.parse(ext.extnValue, SubjectAlternativeName);\n        }\n        else if (ext.extnID === id_ce_extKeyUsage) {\n            extKeyUsage = AsnParser.parse(ext.extnValue, ExtendedKeyUsage);\n        }\n    });\n    // Check that certificate contains subjectAltName (2.5.29.17) extension,\n    if (!subjectAltNamePresent) {\n        throw new Error('Certificate did not contain subjectAltName extension (TPM)');\n    }\n    // TPM-specific values are buried within `directoryName`, so first make sure there are values\n    // there.\n    if (!subjectAltNamePresent[0].directoryName?.[0].length) {\n        throw new Error('Certificate subjectAltName extension directoryName was empty (TPM)');\n    }\n    const { tcgAtTpmManufacturer, tcgAtTpmModel, tcgAtTpmVersion } = getTcgAtTpmValues(subjectAltNamePresent[0].directoryName);\n    if (!tcgAtTpmManufacturer || !tcgAtTpmModel || !tcgAtTpmVersion) {\n        throw new Error('Certificate contained incomplete subjectAltName data (TPM)');\n    }\n    if (!extKeyUsage) {\n        throw new Error('Certificate did not contain ExtendedKeyUsage extension (TPM)');\n    }\n    // Check that tcpaTpmManufacturer (2.23.133.2.1) field is set to a valid manufacturer ID.\n    if (!TPM_MANUFACTURERS[tcgAtTpmManufacturer]) {\n        throw new Error(`Could not match TPM manufacturer \"${tcgAtTpmManufacturer}\" (TPM)`);\n    }\n    // Check that certificate contains extKeyUsage (2.5.29.37) extension and it must contain\n    // tcg-kp-AIKCertificate (2.23.133.8.3) OID.\n    if (extKeyUsage[0] !== '2.23.133.8.3') {\n        throw new Error(`Unexpected extKeyUsage \"${extKeyUsage[0]}\", expected \"2.23.133.8.3\" (TPM)`);\n    }\n    // Validate attestation statement AAGUID against leaf cert AAGUID\n    try {\n        await validateExtFIDOGenCEAAGUID(parsedCert.tbsCertificate.extensions, aaguid);\n    }\n    catch (err) {\n        const _err = err;\n        throw new Error(`${_err.message} (TPM)`);\n    }\n    // Run some metadata checks if a statement exists for this authenticator\n    const statement = await MetadataService.getStatement(aaguid);\n    if (statement) {\n        try {\n            await verifyAttestationWithMetadata({\n                statement,\n                credentialPublicKey,\n                x5c,\n                attestationStatementAlg: alg,\n            });\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (TPM)`);\n        }\n    }\n    else {\n        try {\n            // Try validating the certificate path using the root certificates set via SettingsService\n            await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (TPM)`);\n        }\n    }\n    // Verify signature over certInfo with the public key extracted from AIK certificate.\n    // In the wise words of Yuriy Ackermann: \"Get Martini friend, you are done!\"\n    return verifySignature({\n        signature: sig,\n        data: certInfo,\n        x509Certificate: x5c[0],\n        hashAlgorithm: alg,\n    });\n}\n/**\n * Contain logic for pulling TPM-specific values out of subjectAlternativeName extension\n */\nfunction getTcgAtTpmValues(root) {\n    const oidManufacturer = '2.23.133.2.1';\n    const oidModel = '2.23.133.2.2';\n    const oidVersion = '2.23.133.2.3';\n    let tcgAtTpmManufacturer;\n    let tcgAtTpmModel;\n    let tcgAtTpmVersion;\n    /**\n     * Iterate through the following potential structures:\n     *\n     * (Good, follows the spec)\n     * https://trustedcomputinggroup.org/wp-content/uploads/TCG_IWG_EKCredentialProfile_v2p3_r2_pub.pdf (page 33)\n     * Name [\n     *   RelativeDistinguishedName [\n     *     AttributeTypeAndValue { type, value }\n     *   ]\n     *   RelativeDistinguishedName [\n     *     AttributeTypeAndValue { type, value }\n     *   ]\n     *   RelativeDistinguishedName [\n     *     AttributeTypeAndValue { type, value }\n     *   ]\n     * ]\n     *\n     * (Bad, does not follow the spec)\n     * Name [\n     *   RelativeDistinguishedName [\n     *     AttributeTypeAndValue { type, value }\n     *     AttributeTypeAndValue { type, value }\n     *     AttributeTypeAndValue { type, value }\n     *   ]\n     * ]\n     *\n     * Both structures have been seen in the wild and need to be supported\n     */\n    root.forEach((relName) => {\n        relName.forEach((attr) => {\n            if (attr.type === oidManufacturer) {\n                tcgAtTpmManufacturer = attr.value.toString();\n            }\n            else if (attr.type === oidModel) {\n                tcgAtTpmModel = attr.value.toString();\n            }\n            else if (attr.type === oidVersion) {\n                tcgAtTpmVersion = attr.value.toString();\n            }\n        });\n    });\n    return {\n        tcgAtTpmManufacturer,\n        tcgAtTpmModel,\n        tcgAtTpmVersion,\n    };\n}\n/**\n * Convert TPM-specific SHA algorithm ID's with COSE-specific equivalents. Note that the choice to\n * use ECDSA SHA IDs is arbitrary; any such COSEALG that would map to SHA-256 in\n * `mapCoseAlgToWebCryptoAlg()`\n *\n * SHA IDs referenced from here:\n *\n * https://trustedcomputinggroup.org/wp-content/uploads/TCG_TPM2_r1p59_Part2_Structures_pub.pdf\n */\nfunction attestedNameAlgToCOSEAlg(alg) {\n    if (alg === 'TPM_ALG_SHA256') {\n        return COSEALG.ES256;\n    }\n    else if (alg === 'TPM_ALG_SHA384') {\n        return COSEALG.ES384;\n    }\n    else if (alg === 'TPM_ALG_SHA512') {\n        return COSEALG.ES512;\n    }\n    throw new Error(`Unexpected TPM attested name alg ${alg}`);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4114, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4120, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/verifyAttestationAndroidKey.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { Certificate } from '@peculiar/asn1-x509';\nimport { id_ce_keyDescription, KeyDescription } from '@peculiar/asn1-android';\nimport { convertCertBufferToPEM } from '../../helpers/convertCertBufferToPEM.js';\nimport { validateCertificatePath } from '../../helpers/validateCertificatePath.js';\nimport { verifySignature } from '../../helpers/verifySignature.js';\nimport { convertCOSEtoPKCS } from '../../helpers/convertCOSEtoPKCS.js';\nimport { isCOSEAlg } from '../../helpers/cose.js';\nimport { isoUint8Array } from '../../helpers/iso/index.js';\nimport { MetadataService } from '../../services/metadataService.js';\nimport { verifyAttestationWithMetadata } from '../../metadata/verifyAttestationWithMetadata.js';\n/**\n * Verify an attestation response with fmt 'android-key'\n */\nexport async function verifyAttestationAndroidKey(options) {\n    const { authData, clientDataHash, attStmt, credentialPublicKey, aaguid, rootCertificates, } = options;\n    const x5c = attStmt.get('x5c');\n    const sig = attStmt.get('sig');\n    const alg = attStmt.get('alg');\n    if (!x5c) {\n        throw new Error('No attestation certificate provided in attestation statement (Android Key)');\n    }\n    if (!sig) {\n        throw new Error('No attestation signature provided in attestation statement (Android Key)');\n    }\n    if (!alg) {\n        throw new Error(`Attestation statement did not contain alg (Android Key)`);\n    }\n    if (!isCOSEAlg(alg)) {\n        throw new Error(`Attestation statement contained invalid alg ${alg} (Android Key)`);\n    }\n    /**\n     * Verify that the public key in the first certificate in x5c matches the credentialPublicKey in\n     * the attestedCredentialData in authenticatorData.\n     */\n    // Find the public cert in the certificate as PKCS\n    const parsedCert = AsnParser.parse(x5c[0], Certificate);\n    const parsedCertPubKey = new Uint8Array(parsedCert.tbsCertificate.subjectPublicKeyInfo.subjectPublicKey);\n    // Convert the credentialPublicKey to PKCS\n    const credPubKeyPKCS = convertCOSEtoPKCS(credentialPublicKey);\n    if (!isoUint8Array.areEqual(credPubKeyPKCS, parsedCertPubKey)) {\n        throw new Error('Credential public key does not equal leaf cert public key (Android Key)');\n    }\n    /**\n     * Verify that the attestationChallenge field in the attestation certificate extension data is\n     * identical to clientDataHash.\n     */\n    // Find Android KeyStore Extension in certificate extensions\n    const extKeyStore = parsedCert.tbsCertificate.extensions?.find((ext) => ext.extnID === id_ce_keyDescription);\n    if (!extKeyStore) {\n        throw new Error('Certificate did not contain extKeyStore (Android Key)');\n    }\n    const parsedExtKeyStore = AsnParser.parse(extKeyStore.extnValue, KeyDescription);\n    // Verify extKeyStore values\n    const { attestationChallenge, teeEnforced, softwareEnforced } = parsedExtKeyStore;\n    if (!isoUint8Array.areEqual(new Uint8Array(attestationChallenge.buffer), clientDataHash)) {\n        throw new Error('Attestation challenge was not equal to client data hash (Android Key)');\n    }\n    /**\n     * The AuthorizationList.allApplications field is not present on either authorization list\n     * (softwareEnforced nor teeEnforced), since PublicKeyCredential MUST be scoped to the RP ID.\n     *\n     * (i.e. These shouldn't contain the [600] tag)\n     */\n    if (teeEnforced.allApplications !== undefined) {\n        throw new Error('teeEnforced contained \"allApplications [600]\" tag (Android Key)');\n    }\n    if (softwareEnforced.allApplications !== undefined) {\n        throw new Error('teeEnforced contained \"allApplications [600]\" tag (Android Key)');\n    }\n    const statement = await MetadataService.getStatement(aaguid);\n    if (statement) {\n        try {\n            await verifyAttestationWithMetadata({\n                statement,\n                credentialPublicKey,\n                x5c,\n                attestationStatementAlg: alg,\n            });\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (Android Key)`);\n        }\n    }\n    else {\n        /**\n         * Verify that x5c contains a full certificate path.\n         */\n        const x5cNoRootPEM = x5c.slice(0, -1).map(convertCertBufferToPEM);\n        const x5cRootPEM = x5c.slice(-1).map(convertCertBufferToPEM);\n        try {\n            await validateCertificatePath(x5cNoRootPEM, x5cRootPEM);\n        }\n        catch (err) {\n            const _err = err;\n            throw new Error(`${_err.message} (Android Key)`);\n        }\n        /**\n         * Make sure the root certificate is one of the Google Hardware Attestation Root certificates\n         *\n         * https://developer.android.com/privacy-and-security/security-key-attestation#root_certificate\n         */\n        if (rootCertificates.length > 0 && rootCertificates.indexOf(x5cRootPEM[0]) < 0) {\n            throw new Error('x5c root certificate was not a known root certificate (Android Key)');\n        }\n    }\n    /**\n     * Verify that sig is a valid signature over the concatenation of authenticatorData and\n     * clientDataHash using the public key in the first certificate in x5c with the algorithm\n     * specified in alg.\n     */\n    const signatureBase = isoUint8Array.concat([authData, clientDataHash]);\n    return verifySignature({\n        signature: sig,\n        data: signatureBase,\n        x509Certificate: x5c[0],\n        hashAlgorithm: alg,\n    });\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4249, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4255, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifications/verifyAttestationApple.js"],"sourcesContent":["import { AsnParser } from '@peculiar/asn1-schema';\nimport { Certificate } from '@peculiar/asn1-x509';\nimport { validateCertificatePath } from '../../helpers/validateCertificatePath.js';\nimport { convertCertBufferToPEM } from '../../helpers/convertCertBufferToPEM.js';\nimport { toHash } from '../../helpers/toHash.js';\nimport { convertCOSEtoPKCS } from '../../helpers/convertCOSEtoPKCS.js';\nimport { isoUint8Array } from '../../helpers/iso/index.js';\nexport async function verifyAttestationApple(options) {\n    const { attStmt, authData, clientDataHash, credentialPublicKey, rootCertificates, } = options;\n    const x5c = attStmt.get('x5c');\n    if (!x5c) {\n        throw new Error('No attestation certificate provided in attestation statement (Apple)');\n    }\n    /**\n     * Verify certificate path\n     */\n    try {\n        await validateCertificatePath(x5c.map(convertCertBufferToPEM), rootCertificates);\n    }\n    catch (err) {\n        const _err = err;\n        throw new Error(`${_err.message} (Apple)`);\n    }\n    /**\n     * Compare nonce in certificate extension to computed nonce\n     */\n    const parsedCredCert = AsnParser.parse(x5c[0], Certificate);\n    const { extensions, subjectPublicKeyInfo } = parsedCredCert.tbsCertificate;\n    if (!extensions) {\n        throw new Error('credCert missing extensions (Apple)');\n    }\n    const extCertNonce = extensions.find((ext) => ext.extnID === '1.2.840.113635.100.8.2');\n    if (!extCertNonce) {\n        throw new Error('credCert missing \"1.2.840.113635.100.8.2\" extension (Apple)');\n    }\n    const nonceToHash = isoUint8Array.concat([authData, clientDataHash]);\n    const nonce = await toHash(nonceToHash);\n    /**\n     * Ignore the first six ASN.1 structure bytes that define the nonce as an OCTET STRING. Should\n     * trim off <Buffer 30 24 a1 22 04 20>\n     *\n     * TODO: Try and get @peculiar (GitHub) to add a schema for \"1.2.840.113635.100.8.2\" when we\n     * find out where it's defined (doesn't seem to be publicly documented at the moment...)\n     */\n    const extNonce = new Uint8Array(extCertNonce.extnValue.buffer).slice(6);\n    if (!isoUint8Array.areEqual(nonce, extNonce)) {\n        throw new Error(`credCert nonce was not expected value (Apple)`);\n    }\n    /**\n     * Verify credential public key matches the Subject Public Key of credCert\n     */\n    const credPubKeyPKCS = convertCOSEtoPKCS(credentialPublicKey);\n    const credCertSubjectPublicKey = new Uint8Array(subjectPublicKeyInfo.subjectPublicKey);\n    if (!isoUint8Array.areEqual(credPubKeyPKCS, credCertSubjectPublicKey)) {\n        throw new Error('Credential public key does not equal credCert public key (Apple)');\n    }\n    return true;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAKA;;;;;;;;AACO,eAAe,uBAAuB,OAAO;IAChD,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE,mBAAmB,EAAE,gBAAgB,EAAG,GAAG;IACtF,MAAM,MAAM,QAAQ,GAAG,CAAC;IACxB,IAAI,CAAC,KAAK;QACN,MAAM,IAAI,MAAM;IACpB;IACA;;KAEC,GACD,IAAI;QACA,MAAM,CAAA,GAAA,iQAAA,CAAA,0BAAuB,AAAD,EAAE,IAAI,GAAG,CAAC,gQAAA,CAAA,yBAAsB,GAAG;IACnE,EACA,OAAO,KAAK;QACR,MAAM,OAAO;QACb,MAAM,IAAI,MAAM,GAAG,KAAK,OAAO,CAAC,QAAQ,CAAC;IAC7C;IACA;;KAEC,GACD,MAAM,iBAAiB,qPAAA,CAAA,YAAS,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,sPAAA,CAAA,cAAW;IAC1D,MAAM,EAAE,UAAU,EAAE,oBAAoB,EAAE,GAAG,eAAe,cAAc;IAC1E,IAAI,CAAC,YAAY;QACb,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,eAAe,WAAW,IAAI,CAAC,CAAC,MAAQ,IAAI,MAAM,KAAK;IAC7D,IAAI,CAAC,cAAc;QACf,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,cAAc,uSAAA,CAAA,gBAAa,CAAC,MAAM,CAAC;QAAC;QAAU;KAAe;IACnE,MAAM,QAAQ,MAAM,CAAA,GAAA,gPAAA,CAAA,SAAM,AAAD,EAAE;IAC3B;;;;;;KAMC,GACD,MAAM,WAAW,IAAI,WAAW,aAAa,SAAS,CAAC,MAAM,EAAE,KAAK,CAAC;IACrE,IAAI,CAAC,uSAAA,CAAA,gBAAa,CAAC,QAAQ,CAAC,OAAO,WAAW;QAC1C,MAAM,IAAI,MAAM,CAAC,6CAA6C,CAAC;IACnE;IACA;;KAEC,GACD,MAAM,iBAAiB,CAAA,GAAA,2PAAA,CAAA,oBAAiB,AAAD,EAAE;IACzC,MAAM,2BAA2B,IAAI,WAAW,qBAAqB,gBAAgB;IACrF,IAAI,CAAC,uSAAA,CAAA,gBAAa,CAAC,QAAQ,CAAC,gBAAgB,2BAA2B;QACnE,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 4324, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4330, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/registration/verifyRegistrationResponse.js"],"sourcesContent":["import { decodeAttestationObject, } from '../helpers/decodeAttestationObject.js';\nimport { decodeClientDataJSON } from '../helpers/decodeClientDataJSON.js';\nimport { parseAuthenticatorData } from '../helpers/parseAuthenticatorData.js';\nimport { toHash } from '../helpers/toHash.js';\nimport { decodeCredentialPublicKey } from '../helpers/decodeCredentialPublicKey.js';\nimport { COSEKEYS } from '../helpers/cose.js';\nimport { convertAAGUIDToString } from '../helpers/convertAAGUIDToString.js';\nimport { parseBackupFlags } from '../helpers/parseBackupFlags.js';\nimport { matchExpectedRPID } from '../helpers/matchExpectedRPID.js';\nimport { isoBase64URL } from '../helpers/iso/index.js';\nimport { SettingsService } from '../services/settingsService.js';\nimport { supportedCOSEAlgorithmIdentifiers } from './generateRegistrationOptions.js';\nimport { verifyAttestationFIDOU2F } from './verifications/verifyAttestationFIDOU2F.js';\nimport { verifyAttestationPacked } from './verifications/verifyAttestationPacked.js';\nimport { verifyAttestationAndroidSafetyNet } from './verifications/verifyAttestationAndroidSafetyNet.js';\nimport { verifyAttestationTPM } from './verifications/tpm/verifyAttestationTPM.js';\nimport { verifyAttestationAndroidKey } from './verifications/verifyAttestationAndroidKey.js';\nimport { verifyAttestationApple } from './verifications/verifyAttestationApple.js';\n/**\n * Verify that the user has legitimately completed the registration process\n *\n * **Options:**\n *\n * @param response - Response returned by **@simplewebauthn/browser**'s `startAuthentication()`\n * @param expectedChallenge - The base64url-encoded `options.challenge` returned by `generateRegistrationOptions()`\n * @param expectedOrigin - Website URL (or array of URLs) that the registration should have occurred on\n * @param expectedRPID - RP ID (or array of IDs) that was specified in the registration options\n * @param expectedType **(Optional)** - The response type expected ('webauthn.create')\n * @param requireUserPresence **(Optional)** - Enforce user presence by the authenticator (or skip it during auto registration) Defaults to `true`\n * @param requireUserVerification **(Optional)** - Enforce user verification by the authenticator (via PIN, fingerprint, etc...) Defaults to `true`\n * @param supportedAlgorithmIDs **(Optional)** - Array of numeric COSE algorithm identifiers supported for attestation by this RP. See https://www.iana.org/assignments/cose/cose.xhtml#algorithms. Defaults to all supported algorithm IDs\n */\nexport async function verifyRegistrationResponse(options) {\n    const { response, expectedChallenge, expectedOrigin, expectedRPID, expectedType, requireUserPresence = true, requireUserVerification = true, supportedAlgorithmIDs = supportedCOSEAlgorithmIdentifiers, } = options;\n    const { id, rawId, type: credentialType, response: attestationResponse } = response;\n    // Ensure credential specified an ID\n    if (!id) {\n        throw new Error('Missing credential ID');\n    }\n    // Ensure ID is base64url-encoded\n    if (id !== rawId) {\n        throw new Error('Credential ID was not base64url-encoded');\n    }\n    // Make sure credential type is public-key\n    if (credentialType !== 'public-key') {\n        throw new Error(`Unexpected credential type ${credentialType}, expected \"public-key\"`);\n    }\n    const clientDataJSON = decodeClientDataJSON(attestationResponse.clientDataJSON);\n    const { type, origin, challenge, tokenBinding } = clientDataJSON;\n    // Make sure we're handling an registration\n    if (Array.isArray(expectedType)) {\n        if (!expectedType.includes(type)) {\n            const joinedExpectedType = expectedType.join(', ');\n            throw new Error(`Unexpected registration response type \"${type}\", expected one of: ${joinedExpectedType}`);\n        }\n    }\n    else if (expectedType) {\n        if (type !== expectedType) {\n            throw new Error(`Unexpected registration response type \"${type}\", expected \"${expectedType}\"`);\n        }\n    }\n    else if (type !== 'webauthn.create') {\n        throw new Error(`Unexpected registration response type: ${type}`);\n    }\n    // Ensure the device provided the challenge we gave it\n    if (typeof expectedChallenge === 'function') {\n        if (!(await expectedChallenge(challenge))) {\n            throw new Error(`Custom challenge verifier returned false for registration response challenge \"${challenge}\"`);\n        }\n    }\n    else if (challenge !== expectedChallenge) {\n        throw new Error(`Unexpected registration response challenge \"${challenge}\", expected \"${expectedChallenge}\"`);\n    }\n    // Check that the origin is our site\n    if (Array.isArray(expectedOrigin)) {\n        if (!expectedOrigin.includes(origin)) {\n            throw new Error(`Unexpected registration response origin \"${origin}\", expected one of: ${expectedOrigin.join(', ')}`);\n        }\n    }\n    else {\n        if (origin !== expectedOrigin) {\n            throw new Error(`Unexpected registration response origin \"${origin}\", expected \"${expectedOrigin}\"`);\n        }\n    }\n    if (tokenBinding) {\n        if (typeof tokenBinding !== 'object') {\n            throw new Error(`Unexpected value for TokenBinding \"${tokenBinding}\"`);\n        }\n        if (['present', 'supported', 'not-supported'].indexOf(tokenBinding.status) < 0) {\n            throw new Error(`Unexpected tokenBinding.status value of \"${tokenBinding.status}\"`);\n        }\n    }\n    const attestationObject = isoBase64URL.toBuffer(attestationResponse.attestationObject);\n    const decodedAttestationObject = decodeAttestationObject(attestationObject);\n    const fmt = decodedAttestationObject.get('fmt');\n    const authData = decodedAttestationObject.get('authData');\n    const attStmt = decodedAttestationObject.get('attStmt');\n    const parsedAuthData = parseAuthenticatorData(authData);\n    const { aaguid, rpIdHash, flags, credentialID, counter, credentialPublicKey, extensionsData, } = parsedAuthData;\n    // Make sure the response's RP ID is ours\n    let matchedRPID;\n    if (expectedRPID) {\n        let expectedRPIDs = [];\n        if (typeof expectedRPID === 'string') {\n            expectedRPIDs = [expectedRPID];\n        }\n        else {\n            expectedRPIDs = expectedRPID;\n        }\n        matchedRPID = await matchExpectedRPID(rpIdHash, expectedRPIDs);\n    }\n    // Make sure someone was physically present\n    if (requireUserPresence && !flags.up) {\n        throw new Error('User presence was required, but user was not present');\n    }\n    // Enforce user verification if specified\n    if (requireUserVerification && !flags.uv) {\n        throw new Error('User verification was required, but user could not be verified');\n    }\n    if (!credentialID) {\n        throw new Error('No credential ID was provided by authenticator');\n    }\n    if (!credentialPublicKey) {\n        throw new Error('No public key was provided by authenticator');\n    }\n    if (!aaguid) {\n        throw new Error('No AAGUID was present during registration');\n    }\n    const decodedPublicKey = decodeCredentialPublicKey(credentialPublicKey);\n    const alg = decodedPublicKey.get(COSEKEYS.alg);\n    if (typeof alg !== 'number') {\n        throw new Error('Credential public key was missing numeric alg');\n    }\n    // Make sure the key algorithm is one we specified within the registration options\n    if (!supportedAlgorithmIDs.includes(alg)) {\n        const supported = supportedAlgorithmIDs.join(', ');\n        throw new Error(`Unexpected public key alg \"${alg}\", expected one of \"${supported}\"`);\n    }\n    const clientDataHash = await toHash(isoBase64URL.toBuffer(attestationResponse.clientDataJSON));\n    const rootCertificates = SettingsService.getRootCertificates({\n        identifier: fmt,\n    });\n    // Prepare arguments to pass to the relevant verification method\n    const verifierOpts = {\n        aaguid,\n        attStmt,\n        authData,\n        clientDataHash,\n        credentialID,\n        credentialPublicKey,\n        rootCertificates,\n        rpIdHash,\n    };\n    /**\n     * Verification can only be performed when attestation = 'direct'\n     */\n    let verified = false;\n    if (fmt === 'fido-u2f') {\n        verified = await verifyAttestationFIDOU2F(verifierOpts);\n    }\n    else if (fmt === 'packed') {\n        verified = await verifyAttestationPacked(verifierOpts);\n    }\n    else if (fmt === 'android-safetynet') {\n        verified = await verifyAttestationAndroidSafetyNet(verifierOpts);\n    }\n    else if (fmt === 'android-key') {\n        verified = await verifyAttestationAndroidKey(verifierOpts);\n    }\n    else if (fmt === 'tpm') {\n        verified = await verifyAttestationTPM(verifierOpts);\n    }\n    else if (fmt === 'apple') {\n        verified = await verifyAttestationApple(verifierOpts);\n    }\n    else if (fmt === 'none') {\n        if (attStmt.size > 0) {\n            throw new Error('None attestation had unexpected attestation statement');\n        }\n        // This is the weaker of the attestations, so there's nothing else to really check\n        verified = true;\n    }\n    else {\n        throw new Error(`Unsupported Attestation Format: ${fmt}`);\n    }\n    const toReturn = {\n        verified,\n    };\n    if (toReturn.verified) {\n        const { credentialDeviceType, credentialBackedUp } = parseBackupFlags(flags);\n        toReturn.registrationInfo = {\n            fmt,\n            aaguid: convertAAGUIDToString(aaguid),\n            credentialType,\n            credential: {\n                id: isoBase64URL.fromBuffer(credentialID),\n                publicKey: credentialPublicKey,\n                counter,\n                transports: response.response.transports,\n            },\n            attestationObject,\n            userVerified: flags.uv,\n            credentialDeviceType,\n            credentialBackedUp,\n            origin: clientDataJSON.origin,\n            rpID: matchedRPID,\n            authenticatorExtensionResults: extensionsData,\n        };\n    }\n    return toReturn;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4542, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4548, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/authentication/generateAuthenticationOptions.js"],"sourcesContent":["import { isoBase64URL, isoUint8Array } from '../helpers/iso/index.js';\nimport { generateChallenge } from '../helpers/generateChallenge.js';\n/**\n * Prepare a value to pass into navigator.credentials.get(...) for authenticator authentication\n *\n * **Options:**\n *\n * @param rpID - Valid domain name (after `https://`)\n * @param allowCredentials **(Optional)** - Authenticators previously registered by the user, if any. If undefined the client will ask the user which credential they want to use\n * @param challenge **(Optional)** - Random value the authenticator needs to sign and pass back user for authentication. Defaults to generating a random value\n * @param timeout **(Optional)** - How long (in ms) the user can take to complete authentication. Defaults to `60000`\n * @param userVerification **(Optional)** - Set to `'discouraged'` when asserting as part of a 2FA flow, otherwise set to `'preferred'` or `'required'` as desired. Defaults to `\"preferred\"`\n * @param extensions **(Optional)** - Additional plugins the authenticator or browser should use during authentication\n */\nexport async function generateAuthenticationOptions(options) {\n    const { allowCredentials, challenge = await generateChallenge(), timeout = 60000, userVerification = 'preferred', extensions, rpID, } = options;\n    /**\n     * Preserve ability to specify `string` values for challenges\n     */\n    let _challenge = challenge;\n    if (typeof _challenge === 'string') {\n        _challenge = isoUint8Array.fromUTF8String(_challenge);\n    }\n    return {\n        rpId: rpID,\n        challenge: isoBase64URL.fromBuffer(_challenge),\n        allowCredentials: allowCredentials?.map((cred) => {\n            if (!isoBase64URL.isBase64URL(cred.id)) {\n                throw new Error(`excludeCredential id \"${cred.id}\" is not a valid base64url string`);\n            }\n            return {\n                ...cred,\n                id: isoBase64URL.trimPadding(cred.id),\n                type: 'public-key',\n            };\n        }),\n        timeout,\n        userVerification,\n        extensions,\n    };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AADA;AAAA;;;AAcO,eAAe,8BAA8B,OAAO;IACvD,MAAM,EAAE,gBAAgB,EAAE,YAAY,MAAM,CAAA,GAAA,2PAAA,CAAA,oBAAiB,AAAD,GAAG,EAAE,UAAU,KAAK,EAAE,mBAAmB,WAAW,EAAE,UAAU,EAAE,IAAI,EAAG,GAAG;IACxI;;KAEC,GACD,IAAI,aAAa;IACjB,IAAI,OAAO,eAAe,UAAU;QAChC,aAAa,uSAAA,CAAA,gBAAa,CAAC,cAAc,CAAC;IAC9C;IACA,OAAO;QACH,MAAM;QACN,WAAW,qSAAA,CAAA,eAAY,CAAC,UAAU,CAAC;QACnC,kBAAkB,kBAAkB,IAAI,CAAC;YACrC,IAAI,CAAC,qSAAA,CAAA,eAAY,CAAC,WAAW,CAAC,KAAK,EAAE,GAAG;gBACpC,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,KAAK,EAAE,CAAC,iCAAiC,CAAC;YACvF;YACA,OAAO;gBACH,GAAG,IAAI;gBACP,IAAI,qSAAA,CAAA,eAAY,CAAC,WAAW,CAAC,KAAK,EAAE;gBACpC,MAAM;YACV;QACJ;QACA;QACA;QACA;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 4583, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4589, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/authentication/verifyAuthenticationResponse.js"],"sourcesContent":["import { decodeClientDataJSON } from '../helpers/decodeClientDataJSON.js';\nimport { toHash } from '../helpers/toHash.js';\nimport { verifySignature } from '../helpers/verifySignature.js';\nimport { parseAuthenticatorData } from '../helpers/parseAuthenticatorData.js';\nimport { parseBackupFlags } from '../helpers/parseBackupFlags.js';\nimport { matchExpectedRPID } from '../helpers/matchExpectedRPID.js';\nimport { isoBase64URL, isoUint8Array } from '../helpers/iso/index.js';\n/**\n * Verify that the user has legitimately completed the authentication process\n *\n * **Options:**\n *\n * @param response - Response returned by **@simplewebauthn/browser**'s `startAssertion()`\n * @param expectedChallenge - The base64url-encoded `options.challenge` returned by `generateAuthenticationOptions()`\n * @param expectedOrigin - Website URL (or array of URLs) that the registration should have occurred on\n * @param expectedRPID - RP ID (or array of IDs) that was specified in the registration options\n * @param credential - An internal {@link WebAuthnCredential} corresponding to `id` in the authentication response\n * @param expectedType **(Optional)** - The response type expected ('webauthn.get')\n * @param requireUserVerification **(Optional)** - Enforce user verification by the authenticator (via PIN, fingerprint, etc...) Defaults to `true`\n * @param advancedFIDOConfig **(Optional)** - Options for satisfying more stringent FIDO RP feature requirements\n * @param advancedFIDOConfig.userVerification **(Optional)** - Enable alternative rules for evaluating the User Presence and User Verified flags in authenticator data: UV (and UP) flags are optional unless this value is `\"required\"`\n */\nexport async function verifyAuthenticationResponse(options) {\n    const { response, expectedChallenge, expectedOrigin, expectedRPID, expectedType, credential, requireUserVerification = true, advancedFIDOConfig, } = options;\n    const { id, rawId, type: credentialType, response: assertionResponse } = response;\n    // Ensure credential specified an ID\n    if (!id) {\n        throw new Error('Missing credential ID');\n    }\n    // Ensure ID is base64url-encoded\n    if (id !== rawId) {\n        throw new Error('Credential ID was not base64url-encoded');\n    }\n    // Make sure credential type is public-key\n    if (credentialType !== 'public-key') {\n        throw new Error(`Unexpected credential type ${credentialType}, expected \"public-key\"`);\n    }\n    if (!response) {\n        throw new Error('Credential missing response');\n    }\n    if (typeof assertionResponse?.clientDataJSON !== 'string') {\n        throw new Error('Credential response clientDataJSON was not a string');\n    }\n    const clientDataJSON = decodeClientDataJSON(assertionResponse.clientDataJSON);\n    const { type, origin, challenge, tokenBinding } = clientDataJSON;\n    // Make sure we're handling an authentication\n    if (Array.isArray(expectedType)) {\n        if (!expectedType.includes(type)) {\n            const joinedExpectedType = expectedType.join(', ');\n            throw new Error(`Unexpected authentication response type \"${type}\", expected one of: ${joinedExpectedType}`);\n        }\n    }\n    else if (expectedType) {\n        if (type !== expectedType) {\n            throw new Error(`Unexpected authentication response type \"${type}\", expected \"${expectedType}\"`);\n        }\n    }\n    else if (type !== 'webauthn.get') {\n        throw new Error(`Unexpected authentication response type: ${type}`);\n    }\n    // Ensure the device provided the challenge we gave it\n    if (typeof expectedChallenge === 'function') {\n        if (!(await expectedChallenge(challenge))) {\n            throw new Error(`Custom challenge verifier returned false for registration response challenge \"${challenge}\"`);\n        }\n    }\n    else if (challenge !== expectedChallenge) {\n        throw new Error(`Unexpected authentication response challenge \"${challenge}\", expected \"${expectedChallenge}\"`);\n    }\n    // Check that the origin is our site\n    if (Array.isArray(expectedOrigin)) {\n        if (!expectedOrigin.includes(origin)) {\n            const joinedExpectedOrigin = expectedOrigin.join(', ');\n            throw new Error(`Unexpected authentication response origin \"${origin}\", expected one of: ${joinedExpectedOrigin}`);\n        }\n    }\n    else {\n        if (origin !== expectedOrigin) {\n            throw new Error(`Unexpected authentication response origin \"${origin}\", expected \"${expectedOrigin}\"`);\n        }\n    }\n    if (!isoBase64URL.isBase64URL(assertionResponse.authenticatorData)) {\n        throw new Error('Credential response authenticatorData was not a base64url string');\n    }\n    if (!isoBase64URL.isBase64URL(assertionResponse.signature)) {\n        throw new Error('Credential response signature was not a base64url string');\n    }\n    if (assertionResponse.userHandle &&\n        typeof assertionResponse.userHandle !== 'string') {\n        throw new Error('Credential response userHandle was not a string');\n    }\n    if (tokenBinding) {\n        if (typeof tokenBinding !== 'object') {\n            throw new Error('ClientDataJSON tokenBinding was not an object');\n        }\n        if (['present', 'supported', 'notSupported'].indexOf(tokenBinding.status) < 0) {\n            throw new Error(`Unexpected tokenBinding status ${tokenBinding.status}`);\n        }\n    }\n    const authDataBuffer = isoBase64URL.toBuffer(assertionResponse.authenticatorData);\n    const parsedAuthData = parseAuthenticatorData(authDataBuffer);\n    const { rpIdHash, flags, counter, extensionsData } = parsedAuthData;\n    // Make sure the response's RP ID is ours\n    let expectedRPIDs = [];\n    if (typeof expectedRPID === 'string') {\n        expectedRPIDs = [expectedRPID];\n    }\n    else {\n        expectedRPIDs = expectedRPID;\n    }\n    const matchedRPID = await matchExpectedRPID(rpIdHash, expectedRPIDs);\n    if (advancedFIDOConfig !== undefined) {\n        const { userVerification: fidoUserVerification } = advancedFIDOConfig;\n        /**\n         * Use FIDO Conformance-defined rules for verifying UP and UV flags\n         */\n        if (fidoUserVerification === 'required') {\n            // Require `flags.uv` be true (implies `flags.up` is true)\n            if (!flags.uv) {\n                throw new Error('User verification required, but user could not be verified');\n            }\n        }\n        else if (fidoUserVerification === 'preferred' ||\n            fidoUserVerification === 'discouraged') {\n            // Ignore `flags.uv`\n        }\n    }\n    else {\n        /**\n         * Use WebAuthn spec-defined rules for verifying UP and UV flags\n         */\n        // WebAuthn only requires the user presence flag be true\n        if (!flags.up) {\n            throw new Error('User not present during authentication');\n        }\n        // Enforce user verification if required\n        if (requireUserVerification && !flags.uv) {\n            throw new Error('User verification required, but user could not be verified');\n        }\n    }\n    const clientDataHash = await toHash(isoBase64URL.toBuffer(assertionResponse.clientDataJSON));\n    const signatureBase = isoUint8Array.concat([authDataBuffer, clientDataHash]);\n    const signature = isoBase64URL.toBuffer(assertionResponse.signature);\n    if ((counter > 0 || credential.counter > 0) &&\n        counter <= credential.counter) {\n        // Error out when the counter in the DB is greater than or equal to the counter in the\n        // dataStruct. It's related to how the authenticator maintains the number of times its been\n        // used for this client. If this happens, then someone's somehow increased the counter\n        // on the device without going through this site\n        throw new Error(`Response counter value ${counter} was lower than expected ${credential.counter}`);\n    }\n    const { credentialDeviceType, credentialBackedUp } = parseBackupFlags(flags);\n    const toReturn = {\n        verified: await verifySignature({\n            signature,\n            data: signatureBase,\n            credentialPublicKey: credential.publicKey,\n        }),\n        authenticationInfo: {\n            newCounter: counter,\n            credentialID: credential.id,\n            userVerified: flags.uv,\n            credentialDeviceType,\n            credentialBackedUp,\n            authenticatorExtensionResults: extensionsData,\n            origin: clientDataJSON.origin,\n            rpID: matchedRPID,\n        },\n    };\n    return toReturn;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4754, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4760, "column": 0}, "map": {"version":3,"sources":["file:///home/louis/Documents/my-rental/node_modules/.pnpm/%40simplewebauthn%2Bserver%4013.1.1/node_modules/%40simplewebauthn/server/esm/metadata/mdsTypes.js"],"sourcesContent":["const AlgSign = [\n    'secp256r1_ecdsa_sha256_raw',\n    'secp256r1_ecdsa_sha256_der',\n    'rsassa_pss_sha256_raw',\n    'rsassa_pss_sha256_der',\n    'secp256k1_ecdsa_sha256_raw',\n    'secp256k1_ecdsa_sha256_der',\n    'rsassa_pss_sha384_raw',\n    'rsassa_pkcsv15_sha256_raw',\n    'rsassa_pkcsv15_sha384_raw',\n    'rsassa_pkcsv15_sha512_raw',\n    'rsassa_pkcsv15_sha1_raw',\n    'secp384r1_ecdsa_sha384_raw',\n    'secp512r1_ecdsa_sha256_raw',\n    'ed25519_eddsa_sha512_raw',\n];\nexport {};\n"],"names":[],"mappings":";AAAA,MAAM,UAAU;IACZ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH","ignoreList":[0]}},
    {"offset": {"line": 4778, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4784, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 4786, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4792, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 4801, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}